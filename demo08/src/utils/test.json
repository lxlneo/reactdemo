{"success":true,"data":[{"id":"58e607b0ddee72813eb22323","author_id":"4efc278525fa69ac6900000f","tab":"share","content":"[cnpm cli](https://github.com/cnpm/cnpm) 的 install 速度已经是目前最快的一种 npm installer 了，最近 npm registry 推出了一种全新的 registry api 格式: [Abbreviated metadata format](https://github.com/npm/registry/blob/master/docs/responses/package-metadata.md#abbreviated-metadata-format)，它可以大大减少install 过程中的网络请求数据大小，于是我们也在第一时间实现到 npminstall 中了。\r\n\r\n为了更加平滑地更新过渡，我们计划使用2周时间来做beta测试，然后没什么大问题之后，将会发布正式版本的 cnpm@5 。\r\n\r\n## 尝鲜者来\r\n\r\n直接通过 beta 版本可以参与测试。\r\n\r\n```bash\r\n$ cnpm install cnpm@beta -g \r\n```\r\n\r\n## 问题反馈\r\n\r\n遇到任何问题，请直接回复到 https://github.com/cnpm/cnpm/pull/187 。\r\n\r\n## 回滚\r\n\r\n一键回滚到稳定版本。\r\n\r\n```bash\r\n$ cnpm install cnpm -g\r\n```","title":"cnpm@5 beta 测试招募","last_reply_at":"2017-05-04T07:16:11.103Z","good":false,"top":true,"reply_count":41,"visit_count":13511,"create_at":"2017-04-06T09:17:36.511Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"58d0fb3517f61387400b7e15","author_id":"4f447c2f0a8abae26e01b27d","tab":"share","content":"![screenshot.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1ac00bee5abd7cc1d9a9435f861acba6.png)\r\n\r\n\r\n> 原文地址：https://zhuanlan.zhihu.com/p/25860846\r\n\r\n----\r\n\r\n时光如梭，转眼间 Egg.js 已经开源半年了，我们很荣幸地宣布，Egg.js 正式发布 1.0 版本。\r\n\r\n- 官网传送门：https://eggjs.org\r\n- GitHub：https://github.com/eggjs/egg\r\n- Egg.js 英文文档：与 SwiftGG 翻译组强强联合，中译英的小伙伴招募中，如果你有兴趣，请试译 这篇文章 ，并注明你的 qq 号，发送给 SwiftGG 的同学邮箱(1030041592@qq.com)。期待你的加入！\r\n\r\n## 特点\r\n\r\n- **『企业级的 Node.js Web 基础框架』**，寓意 - 孕育新生。\r\n- 业界领先的 **『微内核 + 插件机制』**，专为团队架构师量身打造的 **『框架定制』** 能力。\r\n- 内建的安全机制与多进程管理模型。\r\n- 高可用，高质量，严格遵循 Semver 规则，测试覆盖率 100%（travis/appveyor)。\r\n- 同时支持 koa 1.x 和 2.x 生态，支持 ES 2017 Async Await。\r\n- 沉淀自阿里各行各业不同领域最佳实践的插件，涵盖了常见的业务开发场景，稳定支撑了 15 和 16 年天猫双11大促，顶级流量压力。\r\n- 渐进式，极具伸缩性，既适合个人小项目快速开发，也适合企业级的团队开发协作。\r\n\r\n> 更详细的特点，以及 Node.js 在阿里的定位，可以参见： [如何评价阿里开源的企业级 Node.js 框架 egg？](https://www.zhihu.com/question/50526101/answer/144952130)\r\n\r\n## 里程碑\r\n\r\n- 2013 年蚂蚁的 chair 框架，可视为 Egg.js 前身。\r\n- 2015 年 11 月，在苏千的召集下，阿里各 BU 的前端骨干齐聚黄龙，闭门共建一周。\r\n- 2016 年初，各 BU 的基础 Web 框架完成升级，在同一套规范的基础上进行差异化定制。\r\n- 2016 年中，成为阿里 Node.js 基建，广泛使用在绝大部分阿里的前端 Node.js 应用。\r\n- 2016 年 09 月，在 [JSConf China 2016](http://2016.jsconf.cn/) 上亮相并宣布开源。\r\n- 2017 年初，经过一周的[闭关直播写文档](https://cnodejs.org/topic/5870e9da04dcf9a706a745f0)，期待已久的 [官方文档](https://eggjs.org/) 诚意登场，足足近 30 篇。\r\n- 2017年 02 月，知乎问答：[如何评价阿里开源的企业级 Node.js 框架 egg？](https://www.zhihu.com/question/50526101/answer/144952130)\r\n- 2017 年 02 月第 2 周，上了 **GitHub Trending** 周榜第三，Star 数增加 1k 多。\r\n- 2017 年 03 月 21 日，Egg.js 正式发布 1.0.0 。\r\n\r\n## 成就\r\n\r\n- 截止到今天，2250+ Star，50+ 插件，10+ 核心开发者，30+ 贡献者。\r\n- GitHub Trending 周榜第三，并上了 Node Weekly 周刊。\r\n- 官网 UV 日均 300+ 。\r\n\r\n![screenshot.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2a69766ae55cab517418e7b2f004d9b9.png)\r\n\r\n- Node TSC Director - Rod Vagg 在 Twitter 上关注并转发。\r\n\r\n![screenshot.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/42f3483f8c7b9a39678958816f477ae2.png)\r\n\r\n## 感言\r\n\r\n![screenshot.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6461618ea8944a1fb5ada1db8aeb7de7.png)\r\n\r\n## 规划\r\n\r\n- Egg.js 英文文档翻译，欢迎加入 [SwiftGG 翻译组](http://swift.gg/) 发起的 [Egg 文档翻译项目](https://github.com/eggjs/egg/issues/363)。\r\n- 继续完善文档，沉淀最佳实践，并帮助社区产出更多的插件和上层框架。\r\n- Node.js 8 LTS 发布后，底层将无缝升级到 Koa@2 。","title":"Egg.js 1.0.0 正式发布 - 企业级 Node.js 框架","last_reply_at":"2017-05-04T17:16:41.043Z","good":false,"top":true,"reply_count":123,"visit_count":21840,"create_at":"2017-03-21T10:06:45.487Z","author":{"loginname":"atian25","avatar_url":"https://avatars.githubusercontent.com/u/227713?v=3&s=120"}},{"id":"58bcded9de61e16b0a771778","author_id":"55efd2234a0501071ed01955","tab":"job","content":"大家好，这是一篇招聘贴。如果您不感兴趣，可以关贴啦，抱歉打扰。\r\n\r\n一年一度的春季校招开始了。\r\n\r\n废话不多说，我们团队的吸引力是这样的\r\n\r\n- 我所在的团队是蚂蚁金服的体验技术部团队，俗称支付宝的母公司\r\n- 我们的技术产品有 [ant design](https://ant.design/) [antv](https://antv.alipay.com/) [egg](https://eggjs.org/) [dva](https://github.com/dvajs/dva) 还有很多为开源或者计划开源的奇思妙想等待你的探索\r\n- 我们参与的对外产品有：借呗、花呗等金融产品\r\n- 我们在数据可视化、node、设计、前端各领域都有探索\r\n- 我们有 @玉伯 [@苏千](https://cnodejs.org/user/fengmk2) [不四](https://cnodejs.org/user/dead-horse) 承玉 偏右(antd) 贯高(egg) 林峰(echarts)，可能你至少了解他们中的几个。\r\n\r\n这次我们在寻找的是：\r\n\r\n- 前端、Node、数据可视化、全端、设计师、React 等领域的同学。\r\n\r\n本次为实习生招聘，希望你是大三或者研二的学生，如果感兴趣，发简历给我吧~ \r\n\r\nshuai.shao@alipay.com","title":"[杭州] 蚂蚁金服体验技术部实习生招聘","last_reply_at":"2017-04-25T06:31:16.055Z","good":false,"top":false,"reply_count":15,"visit_count":1495,"create_at":"2017-03-06T04:00:25.194Z","author":{"loginname":"shaoshuai0102","avatar_url":"https://avatars3.githubusercontent.com/u/456108?v=3&s=120"}},{"id":"580a6a7e541dfb7b50f40a60","author_id":"575eaa97c1518403160a45c4","tab":"share","content":"### I. 写在前面\r\nEgg框架开源都快2个月了，嗯，本以为能看到一些讨论的，结果等了一个月完全没见到大家写点和这个相关的东西，加上官方文档实在是。。。\r\n回归正题，作为国内不错的互联网公司，而且据说也是国内最早开始在生产中使用Node的大佬，我觉得不管外界如何评价，阿里开源的东西还是值得学习下的，最近读了一些里面的实现代码，有一些思路还是很值得公司自己编写组织强约束的Node框架学习的，所以这里算是抛砖引玉，写个基本的controller、router、service、自定义middleware和第三方的koa 1.x插件如何转换应用到egg中来。\r\n本文基于的egg版本为v0.2.1。\r\n### II. Quick Start\r\nEgg是一个强约束的Node框架，这也会其和Express/Koa最大的不同，后者对开发者相对宽松，主要体现在目录结构，编写方式等均可以自定义。\r\nEgg对目录结构等有一系列要求，幸运的是，虽然官方文档几乎是鸭蛋，但是Git上的官方人员还是很贴心的给我们送上了一个自动生成项目目录以及一些简单例子的方式，我们可以来看下：\r\n* 执行如下命令来安装egg-init，在*nix系统下有可能需要sudo权限：\r\n  * npm install egg-init -g\r\n* 执行如下命令生成egg项目框架：\r\n  * egg-init —type simple eggache\r\n* 执行如下命令进入生成的项目目录：\r\n  * cd eggache\r\n* 执行如下命令，安装项目依赖：\r\n  * npm  install\r\n* 执行如下命令，启动egg项目：\r\n  * node index.js\r\n\r\n好了，到这里egg的样例已经运行起来，我们可以在浏览器中访问：\r\n\r\n\t127.0.0.1:7001/news\r\n来观察Hacker News的页面是否正常展现出来，如果页面正常展现，则表明安装成功。\r\n\r\n### III. 框架结构概述\r\n用任意的IDE打开项目目录，可以看下大致的文件目录结构：\r\n* **app**：核心目录，controller文件夹、public静态资源文件夹，middle中间件文件夹，service数据处理组装文件夹、view层展现相关文件夹以及router.js路由文件都在此目录下，这里也是以后大家使用egg开发的主要场所。\r\n* **config**：核心目录，配置文件相关，其中config.default.js中存放的是和当前Node环境无关的配置；config.[env].js文件则存放和Node执行环境相关的配置；plugin.js存放的则是各个插件的package名称和是否开启的配置。这里的Node执行环境，后面会说明。\r\n* **logs**：日志文件输出的目录。\r\n* **index.js**：项目的入口文件。\r\n\r\n这里大致介绍了下Egg框架的组成结构，后面会对两个核心目录app目录和config目录以及入口文件index.js文件的编写方式一一做介绍。\r\n### IV. index.js入口文件\r\n我们从简单的地方开始介绍，首先是Egg框架的入口：index.js，当然文件名随意命名，这里使用的是II节中生成的官方样例。项目启动函数非常简单：\r\n\r\n\trequire('egg').startCluster({\r\n \t\tbaseDir: __dirname,\r\n  \t\tport: 7001, \r\n  \t\tworkers: 1, // default to cpu count\r\n\t});\r\n可以看到，启动文件中引入egg包后调用其startCluster函数，并且传入参数就可以了。实际上经过源码分析，这里面的可以传入的参数完整的是这样的：\r\n\r\n\t{\r\n    \tcustomEgg: '',\r\n    \tbaseDir: process.cwd(),\r\n    \tport: options.https ? 8443 : 7001,\r\n    \tworkers: null,\r\n    \tplugins: null,\r\n    \thttps: false,\r\n   \t \tkey: '',\r\n    \tcert: '',\r\n  \t}\r\n我们来逐个解析下：\r\n* **customEgg**：可选，指egg包所在的目录全路径，这个值框架默认会自动寻找填入。\r\n* **baseDir**：必选，执行egg框架所在的目录全路径，否则采用Node的启动路径。\r\n* **port**：必选，进程的端口号，默认https为8443，http为7001。\r\n* **workers**：可选，启动的子进程个数，默认和当前机器的cpu核数一致。\r\n* **plugins**：可选，插件的配置，如果填写必须填写插件配置的JSON字符串。\r\n* **https**：可选，默认为false。\r\n* **key和cert**：如果选择了https为true，则必选，必须填写可用证书路径。\r\n### V. config目录\r\n#### 一. config.default.js\r\n这个文件主要是用来存放项目所需要的和Node执行环境无关的配置，比如你定义的项目中的一些常量，可以写到config.default.js中。这里关于Node执行环境详细的说明可以参看本节的ENV相关说明。\r\n这个文件编写方式有两种模式，第一种是官方的示例：\r\n\r\n\tmodule.exports = appInfo=>{\r\n\t\treturn {\r\n\t\t\t//你需要添加的项目配置，下面是例子\r\n\t\t\tNAME:”EGG_ACHE”\r\n\t\t}\r\n\t}\r\n可以发现，这个和我们一般编写的配置文件不一样，它exports出来的是一个匿名函数，并且该函数有一个参数appInfo，那么这个appInfo是什么呢？\r\n经过查看egg的源代码（此处忍不住吐槽，0文档看起来真是累...），发现appInfo是Egg框架在自动加载配置文件时传入的一个对象，该对象结构如下：\r\n\r\n\t{\r\n            name: xxx,\r\n            baseDir: xxx,\r\n            env: xxx,\r\n            HOME: xxx,\r\n            pkg: xxx,\r\n\t}\r\n逐个关键字来说明：\r\n* **name**：项目的名称，也就是你的项目主目录的package.json中的name属性对应的值\r\n* **baseDir**：项目主目录所在的全路径\r\n* **env**：项目启动时配置的环境变量，具体参看本节后面的ENV相关说明\r\n* **HOME**：项目启动用户的根路径，process.env.HOME的值，是Node自动生成的\r\n* **pkg**：项目的package.json文件读取后得到的JSON对象\r\n\r\n好吧，吐槽归吐槽，从这里可以看到设计团队想的比较周到，有了这个我们在写配置文件时可以方便的调用这些传入的参数了。\r\n第二种就比较简单了，和普通的配置文件一样，直接使用exports或者module.exports将配置变量返回出来就行了。\r\nEgg框架在配置文件的处理上比较强大，会自动判断是否为函数，如果是函数则会传入appInfo后执行。\r\n#### 二. config.${env}.js\r\n这个文件则主要是用来存放项目中和环境相关的一些配置，比如在local下的接口A地址\r\n配置为：http://a.org，在production下的接口A地址配置为：http://b.org，那么对于接口的A的地址配置来说，就需要分别写到config.local.js和config.production.js中。\r\n该文件的配置内容写法和上一小节中的config.default.js写法完全一致，同样提供了两种配置文件的写法，关于Node环境相关更详细的可以看本节后面的ENV相关说明。\r\n#### 三. ENV相关配置文件命名\r\nEGG中上述的Node环境，即ENV参数，是用来区分开发/测试/线上的不同配置的，经过查看代码，egg提供的三种环境配置的名称分别为：\r\n* **local**：本地开发环境\r\n* **unittest**：单元测试环境\r\n* **production**：线上生产环境\r\n\r\n所以我们在config目录下的环境相关的配置文件可以命名为：config.local.js/config.unittest.js/config.production.js。\r\n这些和env相关的配置文件，会在启动时和config.default.js，由egg依据当前运行设置的env自动merge成一个全局config。\r\n#### 四. ENV的设置\r\n经过查看egg的源代码，可以看到egg框架的env可以采用三种不同的方式进行设置：\r\n* 项目主目录的config文件夹下新建serverEnv，注意该文件没有.js等后缀！然后将上述的local/unittest/production填写进去即可。\r\n* 读取process.env.EGG_SERVER_ENV的值，这种方式需要启动前加上env前缀，例如：EGG_SERVER_ENV=‘local’ node index.js。其实这种是正式部署应用比较推荐的环境变量设置方式。\r\n* 兼容+默认的做法，因为好多公司Node开发使用的env变量名称为NODE_ENV，所以egg判断process.env.NODE_ENV的值为test的话，则ENV更新为unittest；如果process.env.NODE_ENV的值为production的话，则ENV更新为default（？这个相当无厘头，我怀疑是代码写错了，看里面的config加载机制，config.defaule.js是一定会加载的，存储的也是和环境无关的配置）；如果都不是，则更新当前的ENV为local。\r\n### VI. app目录\r\n好了，前面的铺垫全部说完了，我们来看下最重要的app目录，以及如何编写app目录下的相关文件。\r\n#### 一. app目录结构概览\r\napp目录下又按照设计模式分为了数个更细粒度的子目录，如下：\r\n* **controller**：存放controller层的处理文件的位置\r\n* **extend**：存放继承一些自定义公共方法的位置，这个在本节的下面详细说下\r\n* **middleware**：存放自定义中间件文件，所谓的appMiddleware\r\n* **public**：存放项目静态资源的位置\r\n* **service**：Egg框架抽象出来的一个概念，可以认为是带有逻辑处理的model层\r\n* **view**：存放页面模板文件的位置\r\n* **router.js**：编写路由的位置\r\n\r\n文件结构大致描述了下，下面我们逐个目录的分析里面的文件的作用以及如何来编写。\t\t\r\n#### 二. Egg中隐藏的app实例\r\n在讲解下面的目录结构时，我们必须首先弄清一个概念，那就是Egg框架中实际上有一个核心的app实例，地位和Koa以及Express中的app一致，但是我们在Egg框架中无法像Koa/Express那样直接获取到这个app（app 实例是可以拿到的, 在根目录写个 app.js module.export = app => {}，框架支持这样使用app）。\r\n我们来看下这个核心的app如何生成：\r\n\r\n\tconst Application = require(options.customEgg).Application;\r\n\tconst app = new Application({\r\n \t\tbaseDir: options.baseDir,\r\n  \t\tplugins: options.plugins,\r\n\t});\r\n本文不对这个Application类详细展开，我们只需要知道，这个Application最终继承自Koa，同时Egg框架重载了Koa中的createContext函数，熟悉Koa 1.x源码的朋友都知道，这个createContext函数返回的ctx即为所有中间件中的this对象。由于Egg中重载后的ctx其原型指向的是app.context，所以只要在app.context上的所有函数，均可以在所有中间件（包含路由处理函数）中使用this来直接调用。\r\n为什么要特意说明下这个app呢，因为extend下的所有属性最终都会被框架自动挂载到app以及app.request/app.response/app.context/app.Helper.prototype上去。不理解这一点，就会很难理解中间件路由中的this对象和extend目录下的内容。\r\n#### 三. app/controller\r\n这个目录下文件的概念和express以及koa的基本一致，就是路由调度的处理函数，如果文件仅仅想导出一个函数，编写方式如下：\r\n\r\n\tmodule.exports = function *myHelloController() {\r\n    \tthis.body = 'Hello My First Egg Page!';\r\n\t};\r\n由于整个Egg是基于koa 1.x开发的，所以这里做过koa 1.x项目的开发的小伙伴就会很熟悉，和koa 1.x的路由处理函数写法完全一致。\r\n如果controller下的一个js文件想导出多个路由处理函数，编写方式如下：\r\n\r\n\texports.funcA = funtion * (){}\r\n\texports.funcB = funtion * (){}\r\n\t…\r\ncontroller函数里面的this在上面的二节已经说明了，其行为基本和koa1.x一致。\r\n最后，Egg框架会自动将你编写的controller函数挂载到app.controller属性下，挂载的格式为：key是app/controller目录下的文件名进行小驼峰转换为，value是导出的内容，以II节中官方示例为例，其app/controller下的home.js和news.js挂在后为：\r\n\r\n\tapp.controller = {   \r\n\t\thome: [Function: homeController],\r\n    \t\tnews:{ \r\n\t\t\tlist: [Function: newsListController],\r\n        \t\tdetail: [Function: newsDetailController],\r\n        \t\tuser: [Function: userInfoController] \r\n    \t\t} \r\n\t}\r\n如果我们再命名一个文件叫做my_hello.js，内容就是本小节开头写的路由函数，则得到的挂在后的app.controller为：\r\n\r\n\tapp.controller = {   \r\n\t\thome: [Function: homeController],\r\n    \t\tnews:{ \r\n\t\t\tlist: [Function: newsListController],\r\n        \t\tdetail: [Function: newsDetailController],\r\n        \t\tuser: [Function: userInfoController] \r\n    \t\t} ,\r\n\t\tmyHello: [Function: myHelloController]\r\n\t}\r\n看到没，my_hello.js这种风格的会自动被转换为小驼峰形式的名称！\r\n那么到了这里，我们已经明白了如何编写路由文件，以及知道我们所编写的路由文件最后会被挂载到app.controller属性下。\r\n#### 四. app/extend\r\n对于app/extend目录下的内容，如果理解了本大节的第二小节，就比较容易看懂了。app/extend下存在的对应文件分为5类，分别挂载到app的不同属性下：\r\n* **app/extend/application.js**：其导出的对象直接merge到app对象上\r\n* **app/extend/request.js**：其导出的对象直接merge到app.request对象上\r\n* **app/extend/response.js**：其导出的对象直接merge到app.response对象上\r\n* **app/extend/context.js**：其导出的对象直接merge到app.context对象上\r\n* **app/extend/helper.js**：其导出的对象直接merge到app.Helper.prototype原型上，作为原型app.Helper这个类的原型方法。\r\n\r\n这里的1，2，3三个基本上普通开发者无需编写，对于第四点来说，context.js的内容由于最后会merge到app.context中，所以我们如果想在自定义中间件/路由处理函数中的提供一些公共方法，可以直接写到context.js中，然后在自定义中间件/路由处理函数中使用this直接调用，举个例子，context.js内容如下：\r\n\r\n\tmodule.exports = {\r\n    \tgetAche(){\r\n        \treturn 'EGGACHE';\r\n    \t}\r\n\t};\r\n那么，我们在所有的中间件和controller函数中，可以直接调用this.getAche()来获取常量：EGGACHE\r\n接下来是第五点中的app/extend/helper.js，导出的方法会merge到app.Helper类的原型上去，而且比较有意思的是：app.context.helper强制指向了app.Helper的实例（Egg做了单例模式），所以我们同样可以将公共方法写入helper.js文件中，然后在中间件/controller函数中使用this.helper.xxx的形式调用，举个例子，helper.js的内容如下：\r\n\r\n\texports.lowercaseFirst = str => str[0].toLowerCase() + str.substring(1);\r\n我们可以在中间件/controller函数中使用this.helper.lowercaseFirst方法，对字符串第一个字母进行小写处理。\r\napp/extend/helper.js还有一个和context.js不一样的地方在于，Egg框架默认将helper传入了模板引擎的locals参数中，所以在helper中定义的公共方法，我们在各种模板文件中同样可以直接调用，nunjucks中的调用形式为：\r\n\r\n\t{{ helper.lowercaseFirst() }}\r\n#### 五. app/middleware\r\nmiddleware的编写需要和config下的配置文件结合起来，才能编写并且使得一个自定义中间件生效。以一个例子说明，在app/middleware下新建time_access.js，内容如下：\r\n\r\n\tmodule.exports = (options, app)=> {\r\n    \treturn function * timeAccess(next) {\r\n        \tconsole.time(options.key);\r\n        \tyield next;\r\n        \tconsole.timeEnd(options.key);\r\n    \t}\r\n\t};\r\n然后在config/config.default.js中编写如下：\r\n\r\n\tmodule.exports = appInfo=>{\r\n\t\treturn {\r\n\t\t\t//“middleware”是固定的key不可变，值是一个数组，数组中每一个元素都表示开启的中间件名称（将上面的文件面进行小驼峰转换）。\r\n\t\t\tmiddleware: [‘timeAccess’],\r\n\t\t\t//中间件所需的参数，key同样是上面的文件面进行小驼峰转换后的字符换，value就是中间件执行需要的参数。\r\n\t\t\ttimeAccess: {key: ‘Cost Time: ’}\r\n\t\t}\r\n\t}\r\n这样启动项目后，该中间件就生效了。config下文件编写可以参看V大节，我们这里主要来看下自定义中间件的写法，和参数的含义。\r\n可以看到time_access.js导出的是一个匿名函数，该函数的两个参数options和app，其中options对应的就是config.default.js中的timeAccess的值，这里是{key: ‘Cost Time: ’}，app则是本节第二小节中所描述的app实例，并且要使得该中间件生效，必须在config.default.js中的middleware值对应的数组里面有：’timeAccess’。\r\n看到这里你也许会有疑问，我的文件名字明明是time_access.js，为啥config配置中所有填写都是timeAccess呢，这里和controller一样，Egg框架为了统一变量的风格，所以会自动的对文件名进行小驼峰转换，那么time_access转换为小驼峰就是timeAccess。\r\n最后这个匿名函数执行后，返回的是一个标准的koa 1.x的中间件，写法用法和koa 1.x的中间件完全一致，这一块不清楚的可以看Koa 1.x的官方文档学习下。\r\n#### 六. app/public\r\n这个文件夹下存放的是Web服务器所需的静态资源，这一块没什么好说的，随意放，访问使用/public/xxx就行了，xxx为你的静态资源在public目录下的相对路径。比如我们在app/public下新建了一个css文件叫index.css，则我们可以这样访问下载该文件：\r\n127.0.0.1:7001/public/index.css\r\n#### 七. app/service\r\n好吧，终于到了service层了，这一块属于Egg设计的一个服务层，具体来说相当于带了业务逻辑的model，数据的获取和数据的组装都可以在service中完成，然后对于controller函数来说可能就只有两个动作了：\r\n* Service调用\r\n* Page页面渲染\r\n\r\n这样整体的逻辑看起来会更清楚一些。我们以一个例子来理解下service文件的编写方式，这个例子做的比较简单，全量获取百度主页的数据，文件名为BaiduService.js：\r\n\r\n\tmodule.exports = app=>(class BaiduService extends app.Service {\r\n    \tconstructor(ctx) {\r\n        \tsuper(ctx);\r\n        \tthis.config = this.app.config;\r\n    \t}\r\n\t\t\r\n    \t* getBaiduHomePage() {\r\n        \tlet data = yield new Promise((resolve, reject)=> {\r\n            \trequire('request').get('http://www.baidu.com', function (err, res, data) {\r\n                if (err) return reject(err);\r\n                \treturn resolve(data);\r\n            \t})\r\n        \t});\r\n        \treturn data;\r\n    \t}\r\n\t});\r\n可以看到，BaiduService.js导出的依旧是一个匿名函数，该匿名函数的参数app就是本大节中第二小节所描述的app。\r\n这个匿名函数由Egg框架执行后，返回的则是一个class，这个class继承自app.Service，其实在app.Service中，仅仅是对this.ctx和this.app赋值而已。\r\n返回的BaiduService类的构造函数没什么好说的，既然是继承了，必须先super()，然后就可以直接使用this.app来获取app对象，以及this.ctx来获取本次请求的context对象（这个context对象就是中间件和路由中的this对象）。\r\n那么我在这里定义了一个获取百度主页数据的generator成员函数，至此，整个service层样例已经写完了。接下来我们看看如何在controller中调用：\r\n\r\n\tmodule.exports = function *myHelloController() {\r\n    \tlet data = yield this.service.baiduService.getBaiduHomePage();\r\n    \tthis.body = data;\r\n\t};\r\n可以看到，Egg框架将BaiduService这个类new了一个实例，挂载到了this.service.baiduService属性上，因此我们可以直接按照上述的方式调用我们编写的数据获取方法，而且这里的BaiduService.js同样被自动转换成小驼峰的baiduService，所以在controller中的调用形式为：\r\n\r\n\tthis.service.小驼峰文件名.成员函数名\r\n这里的类名是无关紧要的，调用依旧以service目录下创建类的文件名为绑定的key。\r\n**这里要多说一句，经过源码阅读，理清了service加载的逻辑后，可以看到阿里的开发组成员在Service层的逻辑设计还是蛮用心的，this.service和this.controller不一样，它是在每一次请求中第一次使用到时才会new出来的；并且刚才在app/service目录下编写的类也一样，仅在每一次请求中第一次使用到该类时才会实例化；而且不管是this.service还是编写的类，一次会话请求的生命周期中都是单例运行的，这样节省了new类的开销，提升了Egg运行的效率。**\r\n#### 八. app/view\r\n这一块没什么好说的了，模板引擎该怎么用就是怎么用的，但是就和本大节中第四小节描述的那样，app/extend/helper.js中的方法会自动merge到模板执行的locals中，因此在nunjucks中可以使用：\r\n\r\n\t{{ helper.xxx }}\r\n在ejs中可以使用：\r\n\t\r\n\t<% helper.xxx %>\r\n来调用编写到helper.js中的公共方法。\r\n### 九. app/router.js\r\n终于到了app目录下的最后一个文件了，顾名思义，router.js是编写路由的文件，编写形式如下：\r\n\r\n\tmodule.exports = app => {\r\n    \tapp.get('/home', app.controller.home);\r\n    \tapp.get('/myPage', app.controller.myHello);\r\n    \tapp.redirect('/', '/news');\r\n    \tapp.get('/news', app.controller.news.list);\r\n    \tapp.get('/news/item/:id', app.controller.news.detail);\r\n    \tapp.get('/news/user/:id', app.controller.news.user);\r\n\t};\r\n这里依旧是返回的一个匿名函数，参数为app，其实整个Egg的加载逻辑大同小异，花点时间搞清楚controller/service/middleware/config中的一块，别的模块也很容易读懂。\r\n那么这里Egg显然做了一些处理，使得基于Koa 1.x的路由编写看起来和express的风格一致。\r\n由于在本大节第三小节中的controller编写和加载已经阐述过了，我们所编写的路由文件最后会被挂载到app.controller属性下，因此可以直接使用\r\n\r\n\tapp.get(‘/index’, app.controller.xxx)\r\n的形式来编写路由函数。\r\n### VII. 结语\r\n写这东西，也算是挑战了下自己，本文总共5200多字全部纯手打；\r\nEgg框架总体来说设计思路还是非常值得借鉴的，在公司内部协作中，使用这样的强约束框架更能统一风格，提升项目阅读和维护性。\r\n还有就是我现在源码逻辑理的比较清楚集中在master进程fork出来的app子进程，但是对于agent子进程的作用不是很清楚，我大致看了下agent的实现，似乎目前给出的仅仅用到本地开发时由agent监听几个文件目录——只要这些文件目录下的文件发生变更，就由agent来重启app子进程。\r\n最后的是**parent——master——app——agent**四者间的通信的意义也没有了解的比较清楚，希望社区有阿里的大神看在我写的辛苦的份上来给我解答下~","title":"深夜放毒——阿里开源的企业级Node框架Egg使用指南","last_reply_at":"2017-01-10T02:27:26.621Z","good":true,"top":false,"reply_count":40,"visit_count":11732,"create_at":"2016-10-21T19:20:30.342Z","author":{"loginname":"hyj1991","avatar_url":"https://avatars1.githubusercontent.com/u/19908330?v=3&s=120"}},{"id":"4f16442ccae1f4aa270010ab","author_id":"4efc278525fa69ac690000f7","tab":"share","content":"之前和PHP同事讨论node.js的性能问题，看了一些node.js的相关文档，node.js除了拥有非阻塞I/O，快速开发等诸多优点外，其缺点也很明显：\r\n<br/><div>1、单进程，只支持单核CPU，不能充分的利用多核CPU服务器。</div>\r\n<br/><div>2、单进程，一旦这个进程崩掉，那么整个web服务就崩掉了。（当然这个可以通过代码的健壮性来弥补）</div>\r\n<br/><div>开发环境：</div>\r\n<br/><div>vMware Red Hat 虚拟机</div>\r\n<br/><div>CPU： 两个</div>\r\n<br/><div>内存：1GB</div>\r\n<br/><div><strong><span style=\"color: #ff0000\">以下有说的不对的地方还请多多指教：</span></strong></div>\r\n<br/><div><strong>\r\n<br/></strong></div>\r\n<br/><div>近期我借助node.js开发了一套网络聊天室的应用，简单实现了大厅聊天，私聊，群聊。用户信息、群组成员信息和聊天内容等借用redis进行存储。</div>\r\n<br/><div>具体聊天室的功能请参阅我的博客：<a href=\"http://snoopyxdy.blog.163.com/blog/static/60117440201172510426330/\">http://snoopyxdy.blog.163.com/blog/static/60117440201172510426330/</a></div>\r\n<br/><div>现在想要1个CPU绑定一个node.js聊天室进程，需要借助这个命令：<strong><span style=\"color: #ff0000\">taskset,（具体请参阅相关文档）</span></strong></div>\r\n<br/><div>在linux下运行：<span style=\"color: #3366ff\"><span style=\"color: #3366ff\"> </span></span>\r\n<br/><pre class=\"prettyprint\">node server.js\r\n<br/>node server0.js</pre>\r\n<br/></div>\r\n<br/><div>我设定server.js监听端口为8888，server0.js监听端口为8889.</div>\r\n<br/><div>OK，现在2个node.js聊天室程序启动起来了。<span style=\"color: #ff0000\"><strong>但是要注意，这2个聊天室不能相互聊天，但是用户表是一个，就当他是两个不同的房间把。</strong></span>聊天室代码是一套，只是拷贝了一份server.js，在里面监听了不同的端口。</div>\r\n<br/><div>然后我们要对这两个node.js的进程绑定不同的CPU：（目前我的虚拟机就2个CPU）</div>\r\n<br/><pre class=\"prettyprint\">ps -ef | grep node  （用来查看node的进程号）\r\n<br/>root     19277  2517 15 10:12 pts/1    00:00:20 node /usr/local/node/src/chating_express/server.js\r\n<br/>root     19283  2566 18 10:13 pts/2    00:00:20 node /usr/local/node/src/chating_express/server0.js\r\n<br/>root     19291  2384  0 10:15 pts/0    00:00:00 grep node</pre>\r\n<br/><div>找到了上述2个PID后，就利用taskset来进行CPU绑定，命令如下：（这里只写其中一个）</div>\r\n<br/><pre class=\"prettyprint\">taskset -pc 0 19277  （其中0代表CPU0，以此类推）\r\n<br/>pid 19277's current affinity list: 0,1\r\n<br/>pid 19277's new affinity list: 0</pre>\r\n<br/><div>出现上述信息代表绑定成功，同样方法绑定另外一个。</div>\r\n<br/><div>绑定结束后我们怎么知道他们运行在不同的CPU上呢？找另外一台虚拟机，装好webbench，分别对两个node.js聊天室端口进行压力测试，然后用top命令查看各个CPU的使用情况，（小窍门，输入TOP命令，然后按数字“1”，在压力测试时不停的按“ENTER”），结果表明在压力测试server.js端口时CPU0使用率长期保持在60%以上而CPU1则使用率长期在20%以下，而测试server0.js端口时，CPU1长期保持在60%,而CPU0则保持在20%以下，结果表明绑定成功！（之前曾经乌龙了一次，用自己的虚拟机webbench压力测试，结果发现2个CPU使用率都很高，一直检查不出问题，后来发现webbench也要使用CPU的，泪奔！！！）</div>\r\n<br/><div><strong>然后安装nginx，对nginx进行配置，只需在配置文件中加入：（具体nginx的安装和设置请参阅相关文档）</strong></div>\r\n<br/><pre class=\"prettyprint\">upstream node_server_pool {\r\n<br/>server 10.1.1.202:8888 max_fails=1;\r\n<br/>server 10.1.1.202:8889 max_fails=1;\r\n<br/>}\r\n<br/>server\r\n<br/>{\r\n<br/>listen       80;\r\n<br/>server_name 10.1.1.202;\r\n<br/>location /\r\n<br/>{\r\n<br/>proxy_pass http://node_server_pool;\r\n<br/>proxy_set_header Host 10.1.1.202:80;\r\n<br/>proxy_set_header X-Forwarded-For $remote_addr;\r\n<br/>}</pre>\r\n<br/><div>然后软重启nginx服务，访问10.1.1.202这个地址80端口，就可以让nginx做反向代理了和负载均衡了。</div>\r\n<br/><div>注：上述的这些配置需要node.js服务端代码良好的支持，session的存储建议使用redis，这样可以共享session否则需要用到ip_hash了(具体nginx优化配置请参阅相关文档)，在多核CPU上跑多个node.js进程他们之间的内存是不共享的，这点需要牢记啊。</div>\r\n<br/><div>由于之前曾经压力测试过node.js的空框架，发现其内存消耗并不是很高，所以理论上来说，如果4核cpu且内存8G以上，开4个node.js进程跑在一个服务器上，用nginx做负载均衡，其性能和稳定性都应该比单个node.js提升很大。</div>","title":"让node.js充分利用多核服务器的性能","last_reply_at":"2015-07-22T00:49:28.670Z","good":true,"top":false,"reply_count":14,"visit_count":18545,"create_at":"2011-08-30T02:22:52.000Z","author":{"loginname":"DoubleSpout","avatar_url":"https://avatars0.githubusercontent.com/u/971370?v=3&s=120"}},{"id":"5427b91b3923ec3b0e6e32d2","author_id":"4efc278525fa69ac6900000f","tab":"ask","content":"做个调查. 会的 +1, 不会 -1\r\n\r\n私有npm的功能类似 nodejitsu private npm \r\nhttps://www.nodejitsu.com/npm/","title":"cnode 社区如果在阿里云上搭一个私有 npm 服务, 是否有创业公司会使用呢?","last_reply_at":"2016-08-25T01:29:38.040Z","good":false,"top":false,"reply_count":44,"visit_count":36859,"create_at":"2014-09-28T07:30:35.876Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"53233277bfb7097d7a00059e","author_id":"51cfccdd73c638f3708c58d8","content":"![](http://think2011.qiniudn.com/ga1.jpg)\r\n\r\n![](http://think2011.qiniudn.com/ga5.gif)\r\n\r\n<!-- more -->\r\n\r\nnode-webkit能做什么？\r\n===\r\n用Web技术（Node.JS，JavaScript，HTML5）开发桌面应用程序。**（对，我理解的就是这样）**\r\n\r\n大家都做了什么？\r\n===\r\n这里有一份 **优秀作品** 的列表，点[这里看看](https://github.com/rogerwang/node-webkit/wiki/List-of-apps-and-companies-using-node-webkit)。\r\n\r\n准备工作\r\n===\r\n怎么样，看完那些作品，有没有血液沸腾，不知道你有没有，反正我是有的。\r\n接下来实现一个对话聊天的桌面应用，叫做 **葫芦鸭**！，好吧，就是山寨 **小黄鸡** 啦。\r\n\r\n本文重点不在于 **葫芦鸭**，而是node-webkit的简单尝试，所以就不废话了，材料我都准备好了。\r\n所需材料如下：\r\n\r\n- [葫芦鸭](https://github.com/think2011/node-webkit-example.git) `(通过web技术写好的应用)`\r\n- [node-webkit](https://github.com/rogerwang/node-webkit)\r\n\r\n第一步\r\n===\r\n跟node.js一样，在源码的根目录下需要建立 `package.json`，详细的参数和介绍在[这里](https://github.com/rogerwang/node-webkit/wiki/Manifest-format)。\r\n```\r\n{\r\n  \"main\": \"index.html\", // 启动页面\r\n  \"name\": \"ga\",\r\n  \"window\": {\r\n    \"toolbar\": false, // 工具栏\r\n    \"frame\": false, // 框架\r\n    \"width\": 430,\r\n    \"height\": 450,\r\n    \"resizable\": false \r\n  }\r\n}\r\n```\r\n\r\n第二步\r\n===\r\n运行\r\n---\r\n1. 将源码压缩成zip文件 `注意哦，要如图那样的压缩，不能包含文件夹`\r\n![](http://think2011.qiniudn.com/ga2.gif)\r\n\r\n2. 直接将打包好的zip拖入到 `nw.exe`，就算是运行成功了。\r\n![](http://think2011.qiniudn.com/ga3.gif)\r\n打包\r\n---\r\n在当前目录下用命令行执行 `我的用的是shift+右键调出的菜单`\r\n\r\n    copy /b nw.exe+ga.zip app.exe\r\n\r\n注意，第三个参数 `nw.exe+ga.zip`是有顺序的，不能对调\r\n![](http://think2011.qiniudn.com/ga4.gif)\r\n\r\n第三步\r\n===\r\n没了，写完了。\r\n\r\n后续\r\n===\r\n Q 博主，你写的文章怎么这么坑，好像什么都没讲！\r\n A 对，我的文章就是这么坑，因为我对node-webkit不是很了解，想了好久，才写了这么点。\r\n当然node-webkit能做的并不是本文写的那么浅显，例如\r\n\r\n- 解除了浏览器 `沙盒` 限制，像 **葫芦鸭** 中用到的跨域，原本单凭前端是无法实现的。\r\n- 可以使用node.js，除了node.js本身的特性，意味着npm中那么多的扩展可以供你使用。\r\n- node-webkit还实现了本地化的API，例如`菜单栏`，系统的`托盘图标`支持，`系统剪贴板`等\r\n\r\n\r\n---\r\n> ##### 技术： jquery + node-webkit\r\n> ##### 时间： 2014年3月\r\n> ##### 源码： [Guthub](https://github.com/think2011/node-webkit-example.git)\r\n\r\n> ##### 博客： [我的博客](http://think2011.github.io/categories/%E4%BD%9C%E5%93%81/)\r\n\r\n","title":"用node-webkit开发桌面应用","last_reply_at":"2015-01-10T08:43:03.070Z","good":true,"top":false,"reply_count":21,"visit_count":38544,"create_at":"2014-03-14T16:46:47.229Z","author":{"loginname":"think2011","avatar_url":"https://avatars2.githubusercontent.com/u/3961388?v=3&s=120"}},{"id":"5189ff4f63e9f8a54207f60c","author_id":"4efc278525fa69ac690000f7","content":"最近翻阅了node v0.10.4的buffer类的源代码，收获不少，也很久没有在cnode上发表文章了，想把一些收获分享给大家，有什么错误的地方希望大牛们指正啊。\r\n\r\n前阵子有位rrestjs框架的使用者YanQ报告给我这样一个错误，跟我说在用户post很多内容的文章时会crash进程然后报如下错误：（热心的老雷帮我解决了问题）\r\n\r\n    buffer.js:523\r\n        throw new RangeError('targetStart out of bounds');\r\n\r\n错误的原因是api上Class Method: Buffer.concat(list, [totalLength])的第二个参数 totalLength 是list中所存储的所有buffer.length的最大小，而不是list的长度，这边大家需要注意下啊。\r\n\r\n言归正传，简单总结一下吧：\r\n**1、什么时候该用buffer，什么时候不该用**\r\n我看一下如下的测试代码，分别是拼接各种不同长度的字符串，最后直接拼接了10MB的字符串\r\n\r\n    var string,string2,string3;\r\n    var bufstr,bufstr2,bufstr3;\r\n    var j;\r\n    \r\n    console.time('write 100 string')\r\n    for(j=0;j<1000;j++){\r\n    \tvar x = j+'';\r\n    \tstring += x;\r\n    }\r\n    console.timeEnd('write 100 string')\r\n    \r\n    console.time('write 100 buffer')\r\n    bufstr = new Buffer(100)\r\n    for(j=0;j<1000;j++){\r\n    \tvar x = j+'';\r\n    \tbufstr.write(x,j);\r\n    }\r\n    console.timeEnd('write 100 buffer')\r\n    \r\n    \r\n    console.time('write 100000 string')\r\n    for(j=0;j<100000;j++){\r\n    \tvar x = j+'';\r\n    \tstring2 += x;\r\n    }\r\n    console.timeEnd('write 100000 string')\r\n    \r\n    console.time('write 100000 buffer')\r\n    bufstr2 = new Buffer(100000)\r\n    for(j=0;j<100000;j++){\r\n    \tvar x = j+'';\r\n    \tbufstr2.write(x,j);\r\n    }\r\n    console.timeEnd('write 100000 buffer')\r\n    \r\n    console.time('write 1024*1024*10 string')\r\n    for(j=0;j<1024*1024*10;j++){\r\n    \tvar x = j+'';\r\n    \tstring3 += x;\r\n    }\r\n    console.timeEnd('write 1024*1024*10 string')\r\n    \r\n    console.time('write 1024*1024*10 buffer')\r\n    bufstr3 = new Buffer(1024*1024*10)\r\n    for(j=0;j<1024*1024*10;j++){\r\n    \tvar x = j+'';\r\n    \tbufstr3.write(x,j);\r\n    }\r\n    console.timeEnd('write 1024*1024*10 buffer')\r\n\r\n接着是输出结果：\r\n\r\n    write 100 string: 0ms\r\n    write 100 buffer: 6ms\r\n    write 100000 string: 37ms\r\n    write 100000 buffer: 150ms\r\n    write 1024*1024*10 string: 4262ms\r\n    write 1024*1024*10 buffer: 8904ms\r\n\r\n读取速度都不需要测试了，肯定string更快，buffer还需要toString()的操作。\r\n所以我们在保存字符串的时候，该用string还是要用string，就算大字符串拼接string的速度也不会比buffer慢。\r\n那什么时候我们又需要用buffer呢？没办法的时候，当我们保存非utf-8字符串，2进制等等其他格式的时候，我们就必须得使用了。\r\n\r\n\r\n**2、buffer不得不提的8KB**\r\n\r\nbuffer著名的8KB载体，举个例子好比，node把一幢大房子分成很多小房间，每个房间能容纳8个人，为了保证房间的充分使用，只有当一个房间塞满8个人后才会去开新的房间，但是当一次性有多个人来入住，node会保证要把这些人放到一个房间中，比如当前房间A有4个人住，但是一下子来了5个人，所以node不得不新开一间房间B，把这5个人安顿下来，此时又来了4个人，发现5个人的B房间也容纳不下了，只能再开一间房间C了，这样所有人都安顿下来了。但是之前的两间房A和B都各自浪费了4个和3个位置，而房间C就成为了当前的房间。\r\n\r\n具体点说就是当我们实例化一个新的Buffer类，会根据实例化时的大小去申请内存空间，如果需要的空间小于8KB，则会多一次判定，判定当前的8KB载体剩余容量是否够新的buffer实例，如果够用，则将新的buffer实例保存在当前的8KB载体中，并且更新剩余的空间。\r\n\r\n我们做个简单的实验，模拟一个比较严重的内存泄露情况：\r\n\r\n第一次我们将内存泄漏点那行代码注释掉，运行4分钟后，得到如下打印信息，V8已经自动把我分配的内存释放掉了，free men又回到了开始的数值,第二次我们将泄漏点那行代码放开，让全局变量 leak_buf_ary 始终引用着buffer，同样执行10分钟\r\n\r\n\r\n    var os = require('os');\r\n    var leak_buf_ary = [];\r\n    var show_memory_usage = function(){ //打印系统空闲内存\r\n    \tconsole.log('free mem : ' + Math.ceil(os.freemem()/(1024*1024)) + 'mb');\r\n    }\r\n    \r\n    var do_buf_leak = function(){\r\n    \tvar leak_char = 'l'; //泄露的几byte字符\r\n    \tvar loop = 100000;//10万次\r\n    \tvar buf1_ary = []\r\n    \twhile(loop--){\r\n    \t\tbuf1_ary.push(new Buffer(4096)); //申请buf1，占用4096byte空间，会得到自动释放\r\n    \r\n    \t\t//申请buf2，占用几byte空间，将其引用保存在外部数据，不会自动释放\r\n    \t\t//*******\r\n    \t\tleak_buf_ary.push(new Buffer(loop+leak_char));\r\n    \t\t//*******\r\n    \t}\r\n    \tconsole.log(\"before gc\")\r\n    \tshow_memory_usage();\r\n    \tbuf1_ary = null;\r\n    \treturn;\r\n    }\r\n    \r\n    \r\n    console.log(\"process start\")\r\n    show_memory_usage()\r\n    \r\n    do_buf_leak();\r\n    \r\n    var j =10000;\r\n    setInterval(function(){\r\n    \tconsole.log(\"after gc\")\r\n    \tshow_memory_usage()\r\n    },1000*60)\r\n\r\n\r\n第一次结果：\r\n\r\n    process start\r\n    free mem : 5362mb\r\n    before gc\r\n    free mem : 5141mb\r\n    after gc\r\n    free mem : 5163mb\r\n    after gc\r\n    free mem : 5151mb\r\n    after gc\r\n    free mem : 5148mb\r\n    after gc\r\n    free mem : 5556mb\r\n\r\n第二次结果：\r\n\r\n    process start\r\n    free mem : 5692mb\r\n    before gc\r\n    free mem : 4882mb\r\n    after gc\r\n    free mem : 4848mb\r\n    after gc\r\n    free mem : 4842mb\r\n    after gc\r\n    free mem : 4843mb\r\n    after gc\r\n    free mem : 4816mb\r\n    after gc\r\n    free mem : 4822mb\r\n    after gc\r\n    free mem : 4816mb\r\n    after gc\r\n    free mem : 4809mb\r\n    after gc\r\n    free mem : 4810mb\r\n    after gc\r\n    free mem : 4831mb\r\n    after gc\r\n    free mem : 4830mb\r\n\r\n虽然我们释放了4096byte的buffer，但是由于那几byte的字节没有释放掉，将会造成整个8KB的内存都无法释放，如果继续执行循环最终我们的系统内存将耗尽，程序将crash。同样由于我们是依次循环分配 4096+几 byte内存的，所以每块8KB的内存空间都将浪费409Xbyte，在执行循环之后，我们明显发现第二次的内存占用比第一次要大很多。这里我们将近多出了300MB左右的内存消耗。\r\n\r\n\r\n**3、buffer字符串的连接**\r\n我们接受post数据时，node是以流的形式发送上来的，会触发ondata事件，所以我们见到很多代码是这样写的：\r\n\r\n    var http = require('http');\r\n     http.createServer(function (req, res) {\r\n      \r\n      var body = '';\r\n      req.on('data',function(chunk){\r\n    \t//console.log(Buffer.isBuffer(chunk))\r\n    \tbody +=chunk\r\n      })\r\n      req.on('end',function(){\r\n    \t console.log(body)\r\n    \t res.writeHead(200, {'Content-Type': 'text/plain'});\r\n             res.end('Hello World\\n');\r\n      })\r\n      \r\n     \r\n    }).listen(8124);\r\n    \r\n    console.log('Server running at http://127.0.0.1:8124/');\r\n\r\n\r\n下面我们比较一下两者的性能区别，测试代码：\r\n\r\n    var buf = new Buffer('nodejsv0.10.4&nodejsv0.10.4&nodejsv0.10.4&nodejsv0.10.4&');\r\n    console.time('string += buf')\r\n    var s = '';\r\n    for(var i=0;i<10000;i++){\r\n    \ts += buf;\r\n    }\r\n    s;\r\n    console.timeEnd('string += buf')\r\n    \r\n    \r\n    console.time('buf concat')\r\n    var list = [];\r\n    var len=0;\r\n    for(var i=0;i<10000;i++){\r\n    \tlist.push(buf);\r\n    \tlen += buf.length;\r\n    }\r\n    var s2 = Buffer.concat(list, len).toString();\r\n    console.timeEnd('buf concat')\r\n\r\n输出结果，相差近一倍：\r\n\r\n    string += buf: 15ms\r\n    buf concat: 8ms\r\n\r\n在1000次拼接过程中，两者的性能几乎相差一倍，而且当客户上传的是非UTF8的字符串时，直接+=还容易出现错误。\r\n\r\n**4、独享的空间**\r\n如果你想创建一个独享的空间，独立的对这块内存空间进行读写，有两种办法，1是实例化一个超过8KB长度的buffer，另外一个就是使用slowbuffer类。\r\n\r\n**5、buffer的释放**\r\n很遗憾，我们无法手动对buffer实例进行GC，只能依靠V8来进行，我们唯一能做的就是解除对buffer实例的引用。\r\n\r\n**6、清空buffer**\r\n刷掉一块buffer上的数据最快的办法是buffer.fill\r\n\r\n最后如果也想看看buffer源码，希望我的博客对你有帮助：\r\n[浅析node的buffer模块（一创建）][1]\r\n[浅析node的buffer模块（二写入）][2]\r\n[浅析node的buffer模块（三读取）][3]\r\n\r\n\r\n  [1]: http://snoopyxdy.blog.163.com/blog/static/60117440201331683752285/\r\n  [2]: http://snoopyxdy.blog.163.com/blog/static/6011744020134731114493/\r\n  [3]: http://snoopyxdy.blog.163.com/blog/static/601174402013480524058/","title":"浅析nodejs的buffer类","last_reply_at":"2017-04-07T07:27:55.409Z","good":true,"top":false,"reply_count":19,"visit_count":52339,"create_at":"2013-05-08T07:31:27.330Z","author":{"loginname":"DoubleSpout","avatar_url":"https://avatars0.githubusercontent.com/u/971370?v=3&s=120"}},{"id":"5141fda6069911196d5c95c4","author_id":"50b1d976637ffa4155c98364","content":"https://github.com/ktmud/doubanj\r\n\r\n源码如上\r\n\r\n结果示例：  http://www.doubanj.com/people/jyyjcc/read\r\n\r\n其实做这些玩意儿的过程就是不断尝试新东西的过程。欢迎有兴趣的同学一起加入开发。\r\n\r\n如果环境配置时遇到任何困难，欢迎骚扰。","title":"一个node做的豆瓣数据统计网站","last_reply_at":"2014-03-06T13:55:34.126Z","good":false,"top":false,"reply_count":13,"visit_count":6364,"create_at":"2013-03-14T16:41:10.965Z","author":{"loginname":"ktmud","avatar_url":"//gravatar.com/avatar/d84b66754b024f3e3992103ba3cbbf5c?size=48"}},{"id":"516b64596d38277306407936","author_id":"4efc278525fa69ac6900011f","content":"### 异步异常处理  \r\n\r\n#### 异步异常的特点  \r\n由于node的回调异步特性，无法通过`try catch`来捕捉所有的异常：   \r\n\r\n```js\r\ntry {\r\n  process.nextTick(function () {\r\n  \tfoo.bar();\r\n  });\r\n} catch (err) {\r\n  //can not catch it\r\n}\r\n```\r\n\r\n而对于web服务而言，其实是非常希望这样的：   \r\n\r\n```js\r\n//express风格的路由\r\napp.get('/index', function (req, res) {\r\n  try {\r\n    //业务逻辑\r\n  } catch (err) {\r\n    logger.error(err);\r\n    res.statusCode = 500;\r\n    return res.json({success: false, message: '服务器异常'});\r\n  }\r\n});\r\n```\r\n\r\n如果`try catch`能够捕获所有的异常，这样我们可以在代码出现一些非预期的错误时，能够记录下错误的同时，友好的给调用者返回一个500错误。可惜，`try catch`无法捕获异步中的异常。所以我们能做的只能是：  \r\n\r\n```js\r\napp.get('/index', function (req, res) {\r\n  // 业务逻辑  \r\n});\r\n\r\nprocess.on('uncaughtException', function (err) {\r\n  logger.error(err);\r\n});\r\n```\r\n这个时候，虽然我们可以记录下这个错误的日志，且进程也不会异常退出，但是我们是没有办法对发现错误的请求友好返回的，只能够让它超时返回。  \r\n\r\n#### domain   \r\n在node v0.8+版本的时候，发布了一个模块`domain`。这个模块做的就是`try catch`所无法做到的：捕捉异步回调中出现的异常。   \r\n于是乎，我们上面那个无奈的例子好像有了解决的方案：   \r\n\r\n```js\r\nvar domain = require('domain');\r\n\r\n//引入一个domain的中间件，将每一个请求都包裹在一个独立的domain中\r\n//domain来处理异常\r\napp.use(function (req,res, next) {\r\n  var d = domain.create();\r\n  //监听domain的错误事件\r\n  d.on('error', function (err) {\r\n    logger.error(err);\r\n    res.statusCode = 500;\r\n    res.json({sucess:false, messag: '服务器异常'});\r\n    d.dispose();\r\n  });\r\n  \r\n  d.add(req);\r\n  d.add(res);\r\n  d.run(next);\r\n});\r\n\r\napp.get('/index', function (req, res) {\r\n  //处理业务\r\n});\r\n```\r\n\r\n我们通过中间件的形式，引入domain来处理异步中的异常。当然，domain虽然捕捉到了异常，但是还是由于异常而导致的堆栈丢失会导致内存泄漏，所以出现这种情况的时候还是需要重启这个进程的，有兴趣的同学可以去看看[domain-middleware](https://github.com/fengmk2/domain-middleware)这个domain中间件。  \r\n\r\n### 诡异的失效    \r\n我们的测试一切正常，当正式在生产环境中使用的时候，发现`domain`突然失效了！它竟然没有捕获到异步中的异常，最终导致进程异常退出。经过一番排查，最后发现是由于引入了redis来存放session导致的。   \r\n\r\n```js\r\nvar http = require('http');\r\nvar connect = require('connect');\r\nvar RedisStore = require('connect-redis')(connect);\r\nvar domainMiddleware = require('domain-middleware');\r\n\r\nvar server = http.createServer();\r\nvar app = connect();\r\napp.use(connect.session({\r\n  key: 'key',\r\n  secret: 'secret',\r\n  store: new RedisStore(6379, 'localhost')\r\n}));\r\n//domainMiddleware的使用可以看前面的链接\r\napp.use(domainMiddleware({\r\n  server: server,\r\n  killTimeout: 30000\r\n}));\r\n```\r\n\r\n此时，当我们的业务逻辑代码中出现了异常，发现竟然没有被`domain`捕获！经过一番尝试，终于将问题定位到了：  \r\n\r\n```js\r\nvar domain = require('domain');\r\nvar redis = require('redis');\r\nvar cache = redis.createClient(6379, 'localhost');\r\n\r\nfunction error() {\r\n  cache.get('a', function () {\r\n    throw new Error('something wrong');\r\n  });\r\n}\r\n\r\nfunction ok () {\r\n  setTimeout(function () {\r\n    throw new Error('something wrong');\r\n  }, 100);\r\n}\r\nvar d = domain.create();\r\nd.on('error', function (err) {\r\n  console.log(err);\r\n});\r\n\r\nd.run(ok);    //domain捕获到异常\r\nd.run(error); //异常被抛出\r\n```\r\n\r\n奇怪了！都是异步调用，为什么前者被捕获，后者却没办法捕获到呢？   \r\n\r\n### Domain剖析  \r\n回过头来，我们来看看domain做了些什么来让我们捕获异步的请求(代码来自node v0.10.4，此部分可能正在快速变更优化)。如果对domain还不甚了解的同学可以先简单过一下domain的[文档](nodejs.org/api/domain.html)。  \r\n\r\n#### node事件循环机制  \r\n\r\n在看Domain的原理之前，我们先要了解一下`nextTick`和`_tickCallback`的[两个方法](https://github.com/joyent/node/blob/v0.10.4/src/node.js#L395)。  \r\n\r\n```js\r\nfunction laterCall() {\r\n  console.log('print me later');\r\n}\r\n\r\nprocess.nextTick(laterCallback);\r\nconsole.log('print me first');\r\n```\r\n\r\n上面这段代码写过node的人都很熟悉，`nextTick`的作用就是把laterCallback放到下一个事件循环去执行。而`_tickCallback`方法则是一个非公开的方法，这个方法是在当前时间循环结束之后，调用之以继续进行下一个事件循环的入口函数。  \r\n\r\n换而言之，node为事件循环维持了一个队列，`nextTick`入队，`_tickCallback`出列。  \r\n\r\n#### domain的实现  \r\n在了解了node的事件循环机制之后，我们再来看看domain做了些什么。   \r\ndomain自身其实是一个`EventEmitter`对象，它通过事件的方式来传递捕获的错误。这样我们在研究它的时候，就简化到两个点：  \r\n\r\n* 什么时候触发domain的`error`事件：  \r\n  * 进程抛出了异常，没有被任何的`try catch`捕获到，这时候将会触发整个process的`processFatal`，此时如果在domain包裹之中，将会在domain上触发`error`事件，反之，将会在process上触发`uncaughtException`事件。   \r\n\r\n* domain如何在多个不同的事件循环中传递：     \r\n  1. 当domain被实例化之后，我们通常会调用它的`run`方法（如之前在web服务中的使用），来将某个函数在这个domain示例的包裹中执行。被包裹的函数在执行的时候，`process.domain`这个全局变量将会被指向这个domain实例。当这个事件循环中，抛出异常调用`processFatal`的时候，发现`process.domain`存在，就会在domain上触发`error`事件。   \r\n  2. 在require引入domain模块之后，会重写全局的`nextTick`和`_tickCallback`,注入一些domain相关的[代码](https://github.com/joyent/node/blob/v0.10.4/src/node.js#L426)：\r\n\r\n    ```js\r\n    //简化后的domain传递部分代码\r\n    function nextDomainTick(callback) {\r\n      nextTickQueue.push({callback: callback, domain: process.domain});\r\n    }\r\n    \r\n    function _tickDomainCallback() {\r\n      var tock = nextTickQueue.pop();\r\n      //设置process.domain = tock.domain\r\n      tock.domain && tock.domain.enter();\r\n      callback();\r\n      //清除process.domain\r\n      tock.domain && tock.domain.exit();        \r\n      }\r\n    };\r\n    ```\r\n    \r\n  这个是其在多个事件循环中传递domain的关键：`nextTick`入队的时候，记录下当前的domain，当这个被加入队列中的事件循环被`_tickCallback`启动执行的时候，将新的事件循环的`process.domain`置为之前记录的`domain`。这样，在被`domain`所包裹的代码中，不管如何调用`process.nextTick`, domain将会一直被传递下去。   \r\n  3. 当然，node的异步还有两种情况，一种是`event`形式。因此在`EventEmitter`的[构造函数](https://github.com/joyent/node/blob/master/lib/events.js#L28)有如下代码：  \r\n   \r\n  ```js\r\n    if (exports.usingDomains) {\r\n      // if there is an active domain, then attach to it.\r\n      domain = domain || require('domain');\r\n      if (domain.active && !(this instanceof domain.Domain)) {\r\n        this.domain = domain.active;\r\n      }\r\n    }\r\n  ```\r\n  实例化`EventEmitter`的时候，将会把这个对象和当前的domain绑定，当通过`emit`触发这个对象上的事件时，像`_tickCallback`执行的时候一样，回调函数将会重新被当前的`domain`包裹住。   \r\n  4. 而另一种情况，是`setTimeout`和`setInterval`，同样的，在`timer`的源码中，我们也可以发现这样的一句[代码](https://github.com/joyent/node/blob/master/lib/timers.js#L214):   \r\n\r\n  ```js\r\n   if (process.domain) timer.domain = process.domain;\r\n  ```\r\n  \r\n  跟`EventEmmiter`一样，之后这些`timer`的回调函数也将被当前的domain包裹住了。   \r\n  \r\n__node通过在`nextTick`, `timer`, `event`三个关键的地方插入domain的代码，让它们得以在不同的事件循环中传递。__\r\n  \r\n#### 更复杂的domain   \r\n有些情况下，我们可能会遇到需要更加复杂的domain使用。   \r\n\r\n* domain嵌套：我们可能会外层有domain的情况下，内层还有其他的domain，使用情景可以在文档中[找到](http://nodejs.org/api/domain.html#domain_explicit_binding)  \r\n\r\n```js\r\n// create a top-level domain for the server\r\nvar serverDomain = domain.create();\r\n\r\nserverDomain.run(function() {\r\n  // server is created in the scope of serverDomain\r\n  http.createServer(function(req, res) {\r\n    // req and res are also created in the scope of serverDomain\r\n    // however, we'd prefer to have a separate domain for each request.\r\n    // create it first thing, and add req and res to it.\r\n    var reqd = domain.create();\r\n    reqd.add(req);\r\n    reqd.add(res);\r\n    reqd.on('error', function(er) {\r\n      console.error('Error', er, req.url);\r\n      try {\r\n        res.writeHead(500);\r\n        res.end('Error occurred, sorry.');\r\n      } catch (er) {\r\n        console.error('Error sending 500', er, req.url);\r\n      }\r\n    });\r\n  }).listen(1337);\r\n});\r\n```\r\n为了实现这个功能，其实domain还会偷偷的自己维持一个domain的stack，有兴趣的童鞋可以在[这里](https://github.com/joyent/node/blob/v0.10.4/lib/domain.js#L44)看到。   \r\n\r\n\r\n#### 回头解决疑惑  \r\n回过头来，我们再来看刚才遇到的问题：为什么两个看上去都是同样的异步调用，却有一个domain无法捕获到异常？理解了原理之后不难想到，肯定是调用了redis的那个异步调用在抛出错误的这个事件循环内，是不在domain的范围之内的。我们通过一段更加简短的代码来看看，到底在哪里出的问题。   \r\n\r\n```js\r\nvar domain = require('domain');\r\nvar EventEmitter = require('events').EventEmitter;\r\n\r\nvar e = new EventEmitter();\r\n\r\nvar timer = setTimeout(function () {\r\n  e.emit('data');  \r\n}, 10);\r\n\r\nfunction next() {\r\n  e.once('data', function () {\r\n    throw new Error('something wrong here');\r\n  });\r\n}\r\n\r\nvar d = domain.create();\r\nd.on('error', function () {\r\n  console.log('cache by domain');\r\n});\r\n\r\nd.run(next);\r\n\r\n```  \r\n\r\n 此时我们同样发现，错误不会被domain捕捉到，原因很清晰了：`timer`和`e`两个关键的对象在初始化的时候都时没有在domain的范围之内，因此，当在`next`函数中监听的事件被触发，执行抛出异常的回调函数时，其实根本就没有处于domain的包裹中，当然就不会被`domain`捕获到异常了！   \r\n \r\n其实node针对这种情况，专门设计了一个[API：domain.add](http://nodejs.org/api/domain.html#domain_domain_add_emitter)。它可以将domain之外的`timer`和`event`对象，添加到当前domain中去。对于上面那个例子：   \r\n\r\n```js\r\nd.add(timer);\r\n//or\r\nd.add(e);\r\n```\r\n将`timer`或者`e`任意一个对象添加到domain上，就可以让错误被domain捕获了。   \r\n\r\n再来看最开始`redis`导致domain无法捕捉到异常的问题。我们是不是也有办法可以解决呢？   \r\n看[@python](/user/python)发烧友](http://weibo.com/81715239) 的这条[微博](http://weibo.com/1640328892/zrP7PdLkG)我们就能理解，其实对于这种情况，还是没有办法实现最佳的解决方案的。现在对于非预期的异常产生的时候，我们只能够让当前请求超时，然后让这个进程停止服务，之后重新启动。[graceful](https://github.com/fengmk2/graceful)模块配合`cluster`就可以实现这个解决方案。  \r\n\r\n__`domain`十分强大，但不是万能的。__希望在看过这篇文章之后，大家能够正确的使用domian，避免踩坑。:)\r\n\r\n------------\r\n\r\n#### 题外推荐  \r\n在整个问题排查与代码研究过程中，有一个工具起了巨大的作用：`node-inspector`，它可以让node代码在chrome下进行单步调试，能够跟进到node源码之中，[@goddyzhao](http://weibo.com/goddyzhao)的文章[使用node-inspector来调试node](http://blog.goddyzhao.me/post/11522397416/how-to-debug-node-with-node-inspector)详细介绍了如何使用`node-inspector`。","title":"Node.js 异步异常的处理与domain模块解析","last_reply_at":"2017-03-02T15:57:18.579Z","good":false,"top":false,"reply_count":33,"visit_count":41553,"create_at":"2013-04-15T02:22:17.477Z","author":{"loginname":"dead-horse","avatar_url":"https://avatars0.githubusercontent.com/u/985607?v=3&s=120"}},{"id":"516a96d16d38277306349507","author_id":"4efc278625fa69ac69000515","content":"Open Chinese Convert（OpenCC）是一個開源的中文簡繁轉換項目，致力於製作高質量的基於統計預料的簡繁轉換詞庫，還提供函數庫(libopencc)、命令行簡繁轉換工具、人工校對工具、詞典生成程序、在線轉換服務及圖形用戶界面。\r\n\r\n現在OpenCC支持Node.js了。\r\n\r\n安裝方法\r\n\r\n    npm install opencc\r\n\r\nNPM: https://npmjs.org/package/opencc\r\n\r\nGithub: https://github.com/BYVoid/OpenCC\r\n\r\n在線轉換: http://opencc.byvoid.com/ (代碼 https://github.com/BYVoid/opencc-web )\r\n\r\n使用方法\r\n\r\n    var OpenCC = require('opencc');\r\n    \r\n    // Load the default Simplified to Traditional config\r\n    var opencc = new OpenCC('zhs2zht.ini');\r\n    \r\n    // Set conversion mode\r\n    opencc.setConversionMode(OpenCC.CONVERSION_FAST);\r\n    \r\n    // Sync API\r\n    var converted = opencc.convertSync(\"汉字\");\r\n    console.log(converted);\r\n    \r\n    // Async API\r\n    opencc.convert(\"汉字\", function (err, converted) {\r\n      console.log(converted);\r\n    });\r\n","title":"開源的簡繁轉換庫OpenCC支持Node.js了","last_reply_at":"2015-06-14T05:57:12.287Z","good":false,"top":false,"reply_count":18,"visit_count":9122,"create_at":"2013-04-14T11:45:21.582Z","author":{"loginname":"byvoid","avatar_url":"//gravatar.com/avatar/58e26280c99bebadec2dbcadefc4af41?s=48"}},{"id":"50254918f767cc9a5112bf35","author_id":"4efc278625fa69ac69000488","content":"[twei][1] 是一个用 node.js 编写的微博命令行工具. 支持新浪微博的收发.\r\n\r\n安装: `npm install twei -g`\r\n\r\n几个例子: \r\n\r\n    - 查看微博提醒: `twei remind`\r\n    - 查看微博: `twei timeline`\r\n    - 发送微博: `twei update 雨一直下个不停`\r\n    - 发送带图片的微博: `twei update \"你好, 世界\" -i ../example.png -c 114.169938,22.559385`\r\n\r\n欢迎 [fork][2]\r\n\r\n![twei 截屏][3]\r\n\r\n\r\n  [1]: http://justan.github.com/twei/\r\n  [2]: https://github.com/justan/twei\r\n  [3]: http://img.whosemind.net/images/2012/7-30/twei_preview.png","title":"node.js 微博命令行工具","last_reply_at":"2014-12-25T10:31:13.809Z","good":false,"top":false,"reply_count":19,"visit_count":4327,"create_at":"2012-08-10T17:47:04.693Z","author":{"loginname":"ashees","avatar_url":"//gravatar.com/avatar/165d78a59b842dcde5d6485f1b753de7?s=48"}},{"id":"4f2c0391ab3b872077002f00","author_id":"4efc278625fa69ac690005ac","content":"<p>近日读node.js代码，随手记下了一些，不对的地方还请大家指正~</p>\n\n<p>在cnodejs里发帖，有些字符有特殊含义，比如下划线“_”会标识斜体。。。（恕我愚钝）\n看不清楚可以看这里：\n<a href=\"http://www.codingguy.net/?p=195\">http://www.codingguy.net/?p=195</a></p>\n\n<hr/>\n\n<p>这个库全称貌似为Enhanced IO，用多线程实现了异步IO操作，为什么不用libev？因为libev用epoll(linux平台)，不支持regular file。没错，libeio就是给node.js的fs模块用的。</p>\n\n<p><strong>从demo.c看如何使用</strong></p>\n\n<p>翻开代码，有个demo.c，操作很多，常用文件io都包括了。精简一下代码，得到一个minidemo.c:</p>\n\n<pre><code>int respipe [2];\n\nvoid want_poll (void)\n{\n    char dummy;\n    printf (\"want_poll ()\\n\");\n    write (respipe [1], &amp;dummy, 1);\n}\n\nvoid done_poll (void)\n{\n    char dummy;\n    printf (\"done_poll ()\\n\");\n    read (respipe [0], &amp;dummy, 1);\n}\n\nint res_cb (eio_req *req)\n{\n    printf (\"res_cb(%d|%s) = %d\\n\", req-&gt;type, req-&gt;data ? req-&gt;data : \"?\",\n            EIO_RESULT (req));\n    if (req-&gt;result &lt; 0)\n        abort ();\n    return 0;\n}\n\nvoid event_loop (void)\n{\n    // an event loop. yeah.\n    struct pollfd pfd;\n    pfd.fd     = respipe [0];\n    pfd.events = POLLIN;\n    printf (\"\\nentering event loop\\n\");\n    while (eio_nreqs ()) {\n        poll (&amp;pfd, 1, -1);\n        printf (\"eio_poll () = %d\\n\", eio_poll ());\n    }\n    printf (\"leaving event loop\\n\");\n}\n\nint main (void)\n{\n    printf (\"pipe ()\\n\");\n    if (pipe (respipe)) abort ();\n    printf (\"eio_init ()\\n\");\nif (eio_init (want_poll, done_poll)) abort ();\n    eio_mkdir (\"eio-test-dir\", 0777, 0, res_cb, \"mkdir\");\n    event_loop ();\n}\n</code></pre>\n\n<p>这个demo很简单，大体流程如下：\n<img src=\"http://www.codingguy.net/wp-content/uploads/2012/02/demo.png\" alt=\"enter image description here\" title=\"\" /></p>\n\n<ul>\n<li>创建pipe</li>\n<li>初始化eio，注册want<em>poll与done</em>poll</li>\n<li>发出异步操作：mkdir</li>\n<li>启动event loop</li>\n</ul>\n\n<p>第一次看到这段代码，往往被pipe搞迷糊，为什么创建pipe呢？先不管为什么，我们先看是怎么用的。</p>\n\n<p>创建匿名管道后，fd放在respipe数组中，respipe[ 0 ]用于读pipe，respipe[ 1 ]用于写pipe。在want<em>poll和done</em>poll函数中，分别对pipe进行写和读。而want<em>poll与done</em>poll则通过eio_init注册，即，赋值到全局变量中。</p>\n\n<p>接着发出异步操作，创建一个目录eio<em>mkdir(……)，这里的res</em>cb是操作完成之后的回调函数。</p>\n\n<p>最后启动event loop。在这个函数中，有个大循环，eio<em>nreqs()表明尚未完成的请求数量，如果有未完成的请求，则poll respipe[0]，即等待可读，若可读则调用eio</em>poll取回结果。eio<em>poll的执行也会回调res</em>cb函数。</p>\n\n<p>关于前面提到的pipe的作用，这与want<em>poll与done</em>poll机制有关。want<em>poll在响应队列第一次装入请求包的时候被调用；done</em>poll在响应队列为空的时候被调用。want<em>poll向pipe写入数据、done</em>poll从pipe读出数据，读之前通过poll来等待数据可读，若可读，就说明有want<em>poll调用，有异步请求被处理。接下来就可以调用eio</em>poll去接收结果并做回调了。这样，起到了类似锁的作用，同步了生产者消费者类型的资源访问，避免了无意义的循环空转，节约处理器cycle。</p>\n\n<p><strong>小窥源代码</strong></p>\n\n<p>看过demo，我们了解了hello world般的流程。但为了清楚eio接口函数的细节，以及异步io的实现方式，我们要继续读eio.[ch]的代码。话说eio的代码文件并不多，简单介绍一下名字：</p>\n\n<ul>\n<li>ecb.h</li>\n</ul>\n\n<p>这个头文件叫libecb（只有一个ecb.h的lib），全称为The e compiler builtins header/library。它把gcc相关的许多功能封装起来，并兼容不同的gcc版本。比如<em>_ attribute _</em>(attrlist)这些编译器相关的属性，可以用ecb_attribute(attrlist)这个宏来写，且不用考虑编译器版本（3.1以上才支持这个玩意）。</p>\n\n<ul>\n<li>eio.[ch]</li>\n</ul>\n\n<p>就这么一对儿c文件和h文件，先不解释了</p>\n\n<p>下面翻开源代码，从demo中出现的几个接口函数开始，分析一下eio的工作流程。</p>\n\n<p><strong>一切的开始：eio_init</strong></p>\n\n<p>使用eio，第一步就是调用eio<em>init做一堆初始化。初始化mutex、队列、各种计数器，还有注册want</em>poll与done_poll回调函数，这两个函数是由用户提供的。</p>\n\n<pre><code>X_MUTEX_CREATE (wrklock);\nX_MUTEX_CREATE (reslock);\nX_MUTEX_CREATE (reqlock);\nX_COND_CREATE  (reqwait);\nreqq_init (&amp;req_queue);\nreqq_init (&amp;res_queue);\nwrk_first.next =\nwrk_first.prev = &amp;wrk_first;\nstarted  = 0;\nidle     = 0;\nnreqs    = 0;\nnready   = 0;\nnpending = 0;\nwant_poll_cb = want_poll;\ndone_poll_cb = done_poll;\n</code></pre>\n\n<p><strong>业务逻辑的入口：eio_xxx</strong></p>\n\n<p>初始化之后，即可调用eio的异步io函数了。我们以前面demo中创建目录为例，调用eio_mkdir(…)函数。如其他异步io函数，函数体非常简洁，但是逻辑并不简洁：</p>\n\n<pre><code>eio_req *eio_mkdir (const char *path, eio_mode_t mode, int pri, eio_cb cb, void *data)\n{\n    REQ (EIO_MKDIR); PATH; req-&gt;int2 = (long)mode; SEND;\n}\n</code></pre>\n\n<p>真是那各种宏啊，淡定一下，找找定义：</p>\n\n<pre><code>#define REQ(rtype)                                              \\\neio_req *req;                                                 \\\nreq = (eio_req *)calloc (1, sizeof *req);                     \\\nif (!req)                                                     \\\nreturn 0;                                                   \\\nreq-&gt;type    = rtype;                                         \\\nreq-&gt;pri     = pri;                                                    \\\nreq-&gt;finish  = cb;                                                       \\\nreq-&gt;data    = data;                                               \\\nreq-&gt;destroy = eio_api_destroy;\n</code></pre>\n\n<p>这个宏创建了一个eio_req变量，注意是堆空间哦。然后根据rtype，也就是io操作的类型，对其赋值。那些cb等参数都不是宏里面的，从使用场景可以看出是eio _mkdir的参数。接下来是PATH，同样找到定义如下：</p>\n\n<pre><code>#define PATH                                                           \\\nreq-&gt;flags |= EIO_FLAG_PTR1_FREE;                             \\\nreq-&gt;ptr1 = strdup (path);                                        \\\nif (!req-&gt;ptr1)                                                      \\\n{                                                                         \\\n    eio_api_destroy (req);                                               \\\n    return 0;                                                               \\\n}\n</code></pre>\n\n<p>文件io操作嘛，自然要有path。接下来又填写了mode。以上这些操作都是为了构建一个eio<em>req变量。这个eio</em>req的结构定义如下：</p>\n\n<pre><code>struct eio_req\n{\neio_req volatile *next; /* private ETP */\neio_ssize_t result;  /* result of syscall, e.g. result = read (... */\noff_t offs;      /* read, write, truncate, readahead, sync_file_range, fallocate: file offset, mknod: dev_t */\nsize_t size;     /* read, write, readahead, sendfile, msync, mlock, sync_file_range, fallocate: length */\nvoid *ptr1;      /* all applicable requests: pathname, old name; readdir: optional eio_dirents */\nvoid *ptr2;      /* all applicable requests: new name or memory buffer; readdir: name strings */\neio_tstamp nv1;  /* utime, futime: atime; busy: sleep time */\neio_tstamp nv2;  /* utime, futime: mtime */\nint type;        /* EIO_xxx constant ETP */\nint int1;        /* all applicable requests: file descriptor; sendfile: output fd; open, msync, mlockall, readdir: flags */\nlong int2;       /* chown, fchown: uid; sendfile: input fd; open, chmod, mkdir, mknod: file mode, sync_file_range, fallocate: flags */\nlong int3;       /* chown, fchown: gid */\nint errorno;     /* errno value on syscall return */\n#if __i386 || __amd64\nunsigned char cancelled;\n#else\nsig_atomic_t cancelled;\n#endif\nunsigned char flags; /* private */\nsigned char pri;     /* the priority */\nvoid *data;\neio_cb finish;\nvoid (*destroy)(eio_req *req); /* called when request no longer needed */\nvoid (*feed)(eio_req *req);    /* only used for group requests */\nEIO_REQ_MEMBERS\neio_req *grp, *grp_prev, *grp_next, *grp_first; /* private */\n};\n</code></pre>\n\n<p>初始化了一个新的eio<em>req，接下只用了一个SEND完成其余工作，SEND定义很简单，只是调用了eio</em>submit函数：</p>\n\n<pre><code>#define SEND eio_submit (req); return req\n</code></pre>\n\n<p><strong>异步IO的抽象：eio_submit</strong></p>\n\n<p>eio<em>submit只是etp</em>submit的一个封装：</p>\n\n<pre><code>void eio_submit (eio_req *req)\n{\n    etp_submit (req);\n}\n</code></pre>\n\n<p>这个etp_submit几乎是所有io操作的入口，其中的关键代码如下：</p>\n\n<pre><code>X_LOCK (reqlock);\n++nreqs;\n++nready;\nreqq_push (&amp;req_queue, req);\nX_COND_SIGNAL (reqwait);\nX_UNLOCK (reqlock);\netp_maybe_start_thread ();\n</code></pre>\n\n<p>先做计数器累加，然后把刚刚初始化的eio<em>req放在req</em>queue，这是request队列，然后调动etp<em>maybe</em>start<em>thread()，在这个函数中会判断是否调用etp</em>start_thread()启动工作线程。判断逻辑如下：</p>\n\n<pre><code>if (ecb_expect_true (etp_nthreads () &gt;= wanted))\n    return;\nif (ecb_expect_true (0 &lt;= (int)etp_nthreads () + (int)etp_npending () - (int)etp_nreqs ()))\n    return;\n</code></pre>\n\n<p>1．  先判断工作线程数量，如果已到达上限（wanted，默认是4），则直接返回，不做任何操作。\n2．  如果当前的工作线程数量与已处理请求数量的和小于总的请求数量（包括完成与未完成的），则直接返回，不做任何操作\n条件都满足了，接下来会调用etp<em>start</em>thread()函数，通过thread_create创建线程。</p>\n\n<p><strong>线程？！没错，就是线程：eio_proc</strong></p>\n\n<p>在etp<em>start</em>thread()中创建线程，线程函数etp_proc的代码大致如下：</p>\n\n<pre><code>for (;;) {\n    for (;;) {\n        self-&gt;req = req = reqq_shift (&amp;req_queue);\n        if (req)\n            break;\n    }\n        ETP_EXECUTE (self, req);\n        if (!reqq_push (&amp;res_queue, req) &amp;&amp; want_poll_cb)\n        want_poll_cb ();\n}\n</code></pre>\n\n<p>流程概括如下：</p>\n\n<ol>\n<li>从req_queue队列（即，待处理队列）中取出一个eio请求</li>\n<li>调用ETP_EXECUTE完成io的实质操作，这会是一个阻塞过程。</li>\n<li>将eio请求插入res_queue队列（即，已处理队列）</li>\n<li>调用want<em>poll</em>cb回调函数</li>\n</ol>\n\n<p>这里要注意want<em>poll</em>cb的回调条件，当且仅当入队前res_queue为空，才会调用。</p>\n\n<p><strong>执行同步IO：eio_execute</strong></p>\n\n<p>线程函数中有ETP<em>EXECUTE出现，这个宏指代了eio</em>execute函数。在这个函数里面，根据eio<em>req的type域进行switch case，调用相应的io函数完成实质操作，并把结果写到eio</em>req中。示例代码如下：</p>\n\n<pre><code>/* ... */\nswitch (req-&gt;type)\n{\n    /* ... */\n    case EIO_MKDIR:     req-&gt;result = mkdir     (req-&gt;ptr1, (eio_mode_t)req-&gt;int2); break;\n    /* ... */\n}\n/* ... */\n</code></pre>\n\n<p>单纯从异步IO操作的执行看，前面介绍的流程已经能完成了，但是我们不仅要执行IO，还要获取执行的结果，并触发想要的回调。这是通过eio_poll来实现的：</p>\n\n<p><strong>接收报告：eio_poll</strong></p>\n\n<p>如同很多函数一样，eio<em>poll只是套了个壳儿，进而调用etp</em>poll。删减了一些代码，挑出重要逻辑如下：</p>\n\n<pre><code>for (;;) {\n    ETP_REQ *req;\n    etp_maybe_start_thread ();\n    req = reqq_shift (&amp;res_queue);\n    if (req) {\n        if (!res_queue.size &amp;&amp; done_poll_cb)\n        done_poll_cb ();\n    }\n    --nreqs;\n}\n</code></pre>\n\n<p>流程要点如下：</p>\n\n<p>调用etp<em>maybe</em>start<em>thread()，上面已经讲过，在满足条件的情况下会创建工作线程。\n从res</em>queue中取出一个eio<em>req\n如果res</em>queue为空，则触发done<em>poll</em>cb回调</p>\n\n<p><strong>总结</strong></p>\n\n<p>就这样吧，再给出一张图来整体贯穿一下：\n<img src=\"http://www.codingguy.net/wp-content/uploads/2012/02/all.png\" alt=\"enter image description here\" title=\"\" /></p>","title":"Node.js代码阅读笔记之libeio","last_reply_at":"2012-04-25T01:59:14.037Z","good":false,"top":false,"reply_count":4,"visit_count":6430,"create_at":"2012-02-03T15:56:01.338Z","author":{"loginname":"coding","avatar_url":"//gravatar.com/avatar/5a2c582d542fe83eb6cd621f088f3943?s=48"}},{"id":"4fc895068be5d0701222f1c0","author_id":"4fc415584ce4c4101c0e4a7b","content":"   我手上有Alienware M15x一台,2011年5月入手,\r\n   i7 740 4核8线程\r\n   双显卡 集显+gt460m 显存好像是1.5G还是2G.\r\n   8G RAM\r\n   750G DISK\r\n   吸入式光驱有点问题,还在保修,官方可以免费更换,我一直没那个功夫.\r\n\r\n由于手上已经有很多电脑了,再去买感觉太浪费了,因为已经闲置好多台了,但是想要一台Mac的电脑,所以想用我的m15x换.有意向的回复..","title":"有多的苹果木有?换一个.","last_reply_at":"2012-06-02T02:16:53.313Z","good":false,"top":false,"reply_count":4,"visit_count":2071,"create_at":"2012-06-01T10:10:14.085Z","author":{"loginname":"darklowly","avatar_url":"//gravatar.com/avatar/68662b0ff88ec46404fe2447a8399be5?size=48"}},{"id":"4fbcee9b3a7ec1d15106ddba","author_id":"4f62d0e68a06477f5210f9d1","content":"v8 delete操作存在的这个问题\r\n\r\n![enter image description here][1]\r\n\r\n\r\n测试地址在这里，[http://jsperf.com/test-v8-delete][2]，也可以用下面的代码在node中测试\r\n\r\n    var begin = new Date();\r\n    function Foo() {}\r\n    Foo.prototype.x = 1;\r\n    Foo.prototype.y = 2;\r\n    \r\n    //delete Foo.prototype.y;\r\n    \r\n    var foo = new Foo();\r\n    \r\n    var result = 0;\r\n    for (var i = 0; i < 100000000; i++) {\r\n        result = result + foo.x;\r\n    }\r\n    \r\n    var end = new Date();\r\n    console.log(end - begin);\r\n\r\n  [1]: http://www.cnodejs.org/user_data/images/4f62d0e68a06477f5210f9d1/4f62d0e68a06477f5210f9d11337781674468.jpg\r\n  [2]: http://jsperf.com/test-v8-delete","title":"v8 can not handle delete yet","last_reply_at":"2012-05-31T14:22:52.405Z","good":false,"top":false,"reply_count":19,"visit_count":3411,"create_at":"2012-05-23T14:05:15.805Z","author":{"loginname":"jin52yang","avatar_url":"//gravatar.com/avatar/b8d67bbd08fd6ec53c5ec26908982ef3?size=48"}},{"id":"4f50628498766f5a61082c93","author_id":"4f38a5e9301a48d50e028451","content":"发布我的第一个npm package\r\n\r\n[Tracer](https://github.com/baryon/tracer)\r\n\r\n支持彩色输出，文件名，行号，方法名的输出，很容易地支持输出到数据库\r\n\r\n一个非常强大的支持配置的log输出库\r\n\r\n功能\r\n-----\r\n\r\n* 输出log时，带有时间戳，文件名，行号函数名，甚至是调用堆栈\r\n* 输出的log格式支持定制\r\n* 支持自定义的输出函数名\r\n* 支持输出到文件，流，数据库(比如mongodb)等等 \r\n* 支持过滤器功能，因此你看到一个可以支持**彩色Console**输出的功能\r\n\r\n安装\r\n-----\r\n```\r\nnpm install tracer\r\n```\r\n\r\n用法\r\n-----\r\n普通用法  \r\n\r\n```\r\nvar logger = require('tracer').console();\r\n```\r\n\r\n彩色Console   \r\n```\r\nvar logger = require('tracer').colorConsole();\r\n```\r\n\r\n定制输出级别    \r\n```\r\nvar logger = require('tracer').colorConsole({level:2});\r\n```\r\n\r\n缺省的输出方法为    \r\n\r\n 'log', 'trace', 'debug', 'info', 'warn', 'error'\r\n\r\n```\r\nlogger.log('hello');  \r\nlogger.trace('hello', 'world');  \r\nlogger.debug('hello %s',  'world', 123);  \r\nlogger.info('hello %s %d',  'world', 123, {foo:'bar'});  \r\nlogger.warn('hello %s %d %j', 'world', 123, {foo:'bar'});  \r\nlogger.error('hello %s %d %j', 'world', 123, {foo:'bar'}, [1, 2, 3, 4], Object);  \r\n``` \r\n\r\n完全支持类似printf的输出， 支持%s字符串, %d数字, %j JSON，同时可以自己检测输出内容的类型\r\n\r\n更多例子参见[examples目录](https://github.com/baryon/tracer/tree/master/example)\r\n\r\n全部文档见GITHUB [https://github.com/baryon/tracer](https://github.com/baryon/tracer)\r\n","title":"tracer：发布我的第一个npm package, 可以取代console的，支持强大配置的log输出库","last_reply_at":"2015-02-10T05:28:06.607Z","good":false,"top":false,"reply_count":20,"visit_count":6699,"create_at":"2012-03-02T06:02:44.290Z","author":{"loginname":"baryon","avatar_url":"https://avatars3.githubusercontent.com/u/421757?v=3&s=120"}},{"id":"4f3bb617b43c3c846a0784eb","author_id":"4efc5145b0b1a5187d000490","content":"无须多言。\r\n\r\nGithub 主页：[NodeClub][1]\r\n\r\n跪求各位的pull requests！！！\r\n\r\n\r\n  [1]: https://github.com/muyuan/nodeclub","title":"Node Club 开源啦！","last_reply_at":"2015-08-09T11:54:42.787Z","good":false,"top":false,"reply_count":90,"visit_count":20097,"create_at":"2012-02-15T13:41:43.013Z","author":{"loginname":"muyuan","avatar_url":"//gravatar.com/avatar/adc2e9adc268a13d85727067f0a7dbd9?s=48"}},{"id":"4f3d05219605c56a4b021bfa","author_id":"4f3d03239605c56a4b020e42","content":"Node开发的在线LESS编译工具\r\n[http://less.cnodejs.net/][1] \r\n\r\n\r\n![enter image description here][2]\r\n\r\n\r\n  [1]: http://less.cnodejs.net/\r\n  [2]: http://static.data.taobaocdn.com/up/nodeclub/2012/4f3d03239605c56a4b020e421329399097379.png","title":"Node开发的在线LESS编译工具","last_reply_at":"2012-02-18T05:01:08.163Z","good":false,"top":false,"reply_count":4,"visit_count":3196,"create_at":"2012-02-16T13:31:13.808Z","author":{"loginname":"feichang","avatar_url":"//gravatar.com/avatar/d1c524ddbf5e76014e0d219545ff04cc?size=48"}},{"id":"4f3b65a1b43c3c846a05518c","author_id":"4f29161aaa8e490b1100dc3b","content":"JSDev 是[老道（Douglas Crockford）][doug]最近搞的一个不太起眼的小玩意，他的大致思路是，对 JavaScript 做预处理，选择性地把注释转为相应的代码。JSDev 处理的注释块有以下两种形式：\r\n\r\n[doug]: http://www.crockford.com \"JavaScript 编程界的大神，《JavaScript语言精粹》一书的作者，Yahoo! 的程序员 Douglas Crockford\"\r\n\r\n    /*<tag> <stuff>*/\r\n    /*<tag>(<condition>) <stuff>*/\r\n\r\n然后你可以指定 JSDev 开启哪些 tag，JSDev 就会把这块注释改成相应的代码，而这些注释在 JavaScript 正常运行的时候是不会起作用的，在用 JSMin 等工具压缩后也都会全被去掉，这样就方便了 JavaScript 的开发。\r\n\r\n一开始，老道只给出了 C 语言版本的程序，几天后他给出了 JavaScript 版本，我觉得这开始变得有意思了，折腾了两天，想试看能否用到今后的开发项目中去。下面我们先以 C 程序为例说明 JSDev 的用法，然后说说怎样通过 JavaScript 版本把它用在 node 开发或者前端开发过程中。本文假定你在类 Unix 系统（Linux/FreeBSD/Mac OS）下工作并且对命令行、node 编程都有一定了解。\r\n\r\n##C 语言版本 和 JSDev 的用法\r\n先从 github 上 clone 我的 fork，把 C 源码编译成可执行文件。\r\n\r\n    git clone https://github.com/yuest/jsdev.git #clone github 上的源代码到本地\r\n    cd jsdev\r\n    gcc jsdev.c #编译 C 版本\r\n    sudo mv a.out /usr/local/bin/jsdev #把编译好的可执行文件移动到一个 $PATH 底下的目录\r\n\r\n现在我们就可以用 `jsdev` 来运行程序了。可是在命令行输入 `jsdev` 并回车，却什么都没有，原来老道只做了这工具最核心的部分，而未在软件界面下什么功夫，所以连个命令用法提示也没有。作为预处理器，它只会从 stdin 吃进 JavaScript 代码，然后把处理过的代码从 stdout 拉出来，至于文件操作嘛，用 unix 命令行的管道特性就可以啦。\r\n\r\n普及一下，要把文件，比如说 *in.js* 当 stdin 输入到 `jsdev` 程序，使用小于符号 `<` 就行，如 `jsdev <in.js`，而输出就是用大于符号 `>` 啦：`jsdev <in.js >out.js` 就可以。如果要尝试 jsdev，只需要用 `jsdev <in.js` 就可以把结果输出到屏幕上方便查看，或者你甚至可以配合使用 `echo` 命令来测试简单的单行代码。如 `echo \"/*tag 'stuff'*/\" |jsdev tag`\r\n\r\n只运行 `jsdev <in.js >out.js` 这个命令不会对 *in.js* 有任何改动，我们需要以 tag 为参数调用 jsdev 命令来指定需要开启的 tag，多个空格间用空格分开。以例子来说明，如果 *in.js* 代码如下：\r\n\r\n    /*hello console.log('Hello, World!')*/\r\n    /*hi console.log('Hi, there.')*/\r\n\r\n那么 `jsdev <in.js hello` 会输出如下代码：\r\n\r\n    {console.log('Hello, World!')}\r\n    /*hi console.log('Hi, there.')*/\r\n\r\n而 `jsdev <in.js hello hi` 则是：\r\n\r\n    {console.log('Hello, World!')}\r\n    {console.log('Hi, there.')}\r\n\r\n这里的花括号是为了避免与程序中其他部分发生关联而加的，主要问题是 JavaScript 有行尾自动插入分号的设计，如果不加花括号把上下文隔开，可能会与前后行产生关联，比如变成上一行的函数调用之类。花括号实际上是把多个语句复合成一个语句，最常见的地方是用在 if 等仅接受一个语句的关键字后。JavaScript 里面的花括号不会产生一个命名空间。\r\n\r\n你可以为 tag 指定一个函数名，于是此 tag 指定的注释块就会被这个函数名 wrap（有点像 JSONP），如以下 *in.js*：\r\n\r\n    /*log some_variable*/\r\n\r\n用命令 `jsdev <in.js log:console.log` 输出的是：\r\n\r\n    {console.log(some_variable);}\r\n\r\n这可以用于调试代码时打印当时状态下的某些变量值，会比较方便。\r\n\r\n另外还可以为注释块指定条件，如下的 *in.js*：\r\n\r\n    var name = 'Yuest'\r\n    /*hello console.log('Hello, World!')*/\r\n    /*hello(name === 'Celine') console.log('Hello, Celine!')*/\r\n\r\n用命令 `jsdev <in.js hello` 输出：\r\n\r\n    var name = 'Yuest'\r\n    {console.log('Hello, World!')}\r\n    if (name === 'Celine') {console.log('Hello, Celine!')}\r\n\r\n如果运行这段代码，很显然只会输出 `Hello, World!`。\r\n\r\n指定函数和条件也可以同时使用，如：\r\n\r\n    var name = 'Yuest'\r\n    /*log 'Hello, World!'*/\r\n    /*log(name === 'Ling') 'Hello, Ling!'*/\r\n\r\n用命令 `jsdev <in.js log:console.log` 输出：\r\n\r\n    var name = 'Yuest'\r\n    {console.log('Hello, World!');}\r\n    if (name === 'Ling') {console.log('Hello, Ling!');}\r\n\r\n和前面几乎是一样的，但注释短了不少。以上就是关于 JSDev 使用方法的一切了。其实最核心的是 `/*<tag> <stuff>*/` 这种形式，我们可以完全只用这种形式来达到上面一样的目的：\r\n\r\n    var name = 'Yuest'\r\n    /*hello console.log('Hello, World!')*/\r\n    /*hello if (name === 'Ling') {console.log('Hello, Ling!')}*/\r\n\r\n上面的代码用命令 `jsdev <in.js hello` 输出：\r\n\r\n    var name = 'Yuest'\r\n    {console.log('Hello, World!')}\r\n    {if (name === 'Ling') {console.log('Hello, Ling!')}}\r\n\r\n所以可以看出，为 tag 指定函数名和条件只是做了一些简化而已。\r\n\r\n哦对了，还忘了 `jsdev` 命令接受一个 `-comment` 参数为输出的文件头部添加注释，如对于上面的 *in.js* 文件，运行一下命令：\r\n\r\n    jsdev <in.js hello -comment \"Author: Yuest\" -comment \"This is a temporary file generated by JSDev\"\r\n\r\n会获得：\r\n\r\n    // Author: Yuest\r\n    // This is a temporary file generated by JSDev\r\n    var name = 'Yuest'\r\n    {console.log('Hello, World!')}\r\n    {if (name === 'Ling') {console.log('Hello, Ling!')}}\r\n    \r\n嗯，以上就真的是关于 JSDev 用法的一切了，而关于要如何用好它，则需要他的使用者有一点想象力。比如，你可以写一些 bash 脚本什么的。下面说说 JavaScript 版本的 JSDev 以及我想到的用在 node 项目的方法。\r\n\r\n##JavaScript 版本和 node 中用法\r\n\r\n老道给出的 jsdev.js 里面只定义了一个 JSDEV 函数，接受三个参数，第一个参数是要处理的源代码，第二、三个参数是两个数组，分别指定 tag 和注释。如果上面最后一条命令用 JavaScript 版本来处理，就应该是：\r\n\r\n    JSDEV( input\r\n         , ['hello']\r\n         , ['Author: Yuest', 'This is a temporary file generated by JSDev'])\r\n         \r\n我的 fork 为 node 加上了 `exports.JSDEV = JSDEV`，并 publish 到 npm 上了，你只需 `npm install jsdev` 或者在 package.json 里面加上 jsdev 的依赖，并在源码里\r\n\r\n    var JSDEV = require('jsdev').JSDEV\r\n    \r\n就可以使用 JavaScript 版本的 `JSDEV()` 函数了。\r\n         \r\n因为 node 可以通过修改 module.constructor.prototype._compile 来修改要载入的文件，非常适合拿来应用 JSDev 这种预处理器。我的想法是，一个文件要开启哪些 tag 下的注释块，应该在其自身（也是用注释）来描述。如果程序载入了 `jsdev` 并调用其 `replaceRequire` 方法（`require('jsdev').replaceRequire()`），之后再 require 进的文件有 `//[@jsdev](/user/jsdev) tag1 tag2` 这样的注释，就会用 jsdev 开启 tag1、tag2 指定的注释块。\r\n\r\n指定开启 tags 的规则这样写：\r\n\r\n    //[@jsdev](/user/jsdev)(test,production) tag1 tag2\r\n    //[@jsdev](/user/jsdev)(development) tag3\r\n    \r\n以上注释行表示在环境变量 `NODE_ENV=test` 或 `NODE_ENV=production` 的时候开启本文件的 tag1 tag2 注释块，在 `NODE_ENV=development` 时开启 tag3 注释块。如果没有 jsdev 后面的括号，默认是 development，因此可以写成\r\n\r\n    //[@jsdev](/user/jsdev)(test,production) tag1 tag2\r\n    //[@jsdev](/user/jsdev) tag3\r\n\r\n例如有 a.js:\r\n\r\n    require('jsdev').replaceRequire()\r\n    require('./b')\r\n    \r\nb.js:\r\n\r\n    //[@jsdev](/user/jsdev)(test,production) hello\r\n    //[@jsdev](/user/jsdev) hi\r\n    /*hello console.log('hello')*/\r\n    /*hi console.log('hi')*/\r\n    \r\n则运行 `node a.js` 会输出 `hi`，而运行`NODE_ENV=test` 则会输出 `hello`\r\n\r\n另外，对于前端开发也是一样的，有 `replaceStatic()` 函数，可以替换 connect/express 的 static middleware。这样就可以预处理通过 static middleware 返回到浏览器的 js 文件。文件内 tag 开启的规则和前面写的一样。需要注意的是要在使用 `connect.static(root)` 之前调用 `replaceStatic()`。\r\n\r\n更多的例子可以参考[我写的测试][test]，在迁出的代码中 `./runtests` （当然要确保 npm 依赖已经安装，即在目录下运行 `npm install`）就可以运行测试。我在这里提供这个很通用的工具的用法，要怎样用好它（什么环境设定什么 tag 之类），就要靠用户的想象力了吧。\r\n\r\n[test]: https://github.com/yuest/jsdev/tree/master/test\r\n\r\n有不足的地方欢迎指证，可以到 github 里面去提 issue。","title":"JSDev：一个优化 JavaScript开发过程的小工具","last_reply_at":"2012-02-29T03:30:44.049Z","good":false,"top":false,"reply_count":2,"visit_count":3021,"create_at":"2012-02-15T07:58:25.004Z","author":{"loginname":"yuest","avatar_url":"//gravatar.com/avatar/e5efb8b6097310dcf1681d641d69e6be?size=48"}},{"id":"4f3b18d8b43c3c846a02747f","author_id":"4f2cbd63ab3b872077025d72","content":"给js传递一个中文参数 比如中文目录路径， js里接受到得参数process.argv就是乱码","title":"Windows下接受中文参数 编码异常","last_reply_at":"2012-02-15T03:11:53.627Z","good":false,"top":false,"reply_count":6,"visit_count":2926,"create_at":"2012-02-15T02:30:48.557Z","author":{"loginname":"im007boy","avatar_url":"//gravatar.com/avatar/91445e7362e315e69c60001a0be5a771?size=48"}},{"id":"4f3a374f3a3890785900a1cf","author_id":"4f293cd9aa8e490b110228be","content":"http://club.cnodejs.org 定位是?\r\n\r\n- c.js 大本营\r\n- 文档中心\r\n- 活动发布中心\r\n- QA 中心\r\n\r\n那么,,,\r\n\r\n    - 应该不是 bbs 了?!\r\n    - 俺的问题/回复 有人回复了,应该邮件提醒吧!\r\n    - 不然,天天来人肉刷,,,忒囧了,,\r\n\r\n ","title":"club.cnodejs.org 需要邮件提醒","last_reply_at":"2012-02-14T15:43:18.700Z","good":false,"top":false,"reply_count":9,"visit_count":2536,"create_at":"2012-02-14T10:28:31.622Z","author":{"loginname":"zoomquiet","avatar_url":"//gravatar.com/avatar/99abbbb45474ff8910aa844a2af2092f?size=48"}},{"id":"4f1933b6817ae4105c013c26","author_id":"4f1932a2817ae4105c013914","content":"第一感觉就是很独特很独特， 这是一个自己开发的Node.JS论坛吗？","title":"这个论坛时node.js写的吗？","last_reply_at":"2013-06-28T09:35:20.877Z","good":false,"top":false,"reply_count":14,"visit_count":7558,"create_at":"2012-01-20T09:28:22.537Z","author":{"loginname":"chepy","avatar_url":"//gravatar.com/avatar/a4dd7ee932f9c73e02d4f4fdfc0fd12a?s=48"}},{"id":"4f181950817ae4105c00367d","author_id":"4efc278625fa69ac690001ad","content":"NodeJS文档中我们可以看到kill这个方法，给进程发送一个信号  \r\n\r\n    process.kill(pid, [signal])\r\n\r\n其中第二个可选参数 signal ,默认会发送 SIGTERM 。\r\n\r\n那到底有哪些signal呢？ 文档中并没有列出，不过原文中有个\"See kill(2) \" ，而且看起来发送的信号和linux下的kill命令差不多嘛，于是 \r\n\r\n    >man kill\r\n\r\n得到如下结果：\r\n\r\n    Name     Num   Action    Description\r\n           0          0   n/a       exit code indicates if a signal may be sent\r\n           ALRM      14   exit\r\n           HUP        1   exit\r\n           INT        2   exit\r\n           KILL       9   exit      cannot be blocked\r\n           PIPE      13   exit\r\n           POLL           exit\r\n           PROF           exit\r\n           TERM      15   exit\r\n           USR1           exit\r\n           USR2           exit\r\n           VTALRM         exit\r\n           STKFLT         exit      might not be implemented\r\n           PWR            ignore    might exit on some systems\r\n           WINCH          ignore\r\n           CHLD           ignore\r\n           URG            ignore\r\n           ..................\r\n         \r\n嘎多的signal，检查一下发现，NodeJS中的signal的名字只要加上  SIG 前缀即可，比如 SIGALRM，SIGHUP............. \r\n\r\n然后：\r\n\r\n    process.on('SIGINT', function () {\r\n      console.log('Got SIGINT.  Press Control-D to exit.');\r\n    });\r\n\r\n可以根据不同的信号绑定不同的事件","title":"process如何使用信号(signal)","last_reply_at":"2012-01-19T13:55:08.769Z","good":false,"top":false,"reply_count":1,"visit_count":3507,"create_at":"2012-01-19T13:23:28.980Z","author":{"loginname":"fish","avatar_url":"//gravatar.com/avatar/d24fc5b1c6b84dae95dd23ba1c7ebbcb?size=48"}},{"id":"4f17ade89f40a833520091c4","author_id":"4efc278525fa69ac6900000f","content":"CNodeJS.ORG为国内最专业的Node.JS开源技术社区，致力于Node.JS的技术研究。\r\n\r\nCNode社区由一批热爱Node技术的工程师发起，目前已经吸引了互联网各个公司的专业技术人员加入，我们非常欢迎更多对node感兴趣的朋友加入我们<strong>(发邮件到 <span style=\"color: #008000;\">nodejs[@126](/user/126).com</span>)</strong>。\r\n\r\n包括：\r\n<ul>\r\n\t<li>作为志愿者或者协作者加入我们一起对node.js的研究和应用</li>\r\n\t<li>撰写node.js的技术文章，在cnodejs.org上发表</li>\r\n\t<li>在你的项目中使用node.js，以及我们开发的模块</li>\r\n\t<li>愿意对node.js的源码进行贡献</li>\r\n\t<li>帮助推广node.js</li>\r\n\t<li>与我们cnodejs.org交换友情链接</li>\r\n</ul>\r\n<h3><a href=\"http://groups.google.com/group/cnodejs?hl=zh-CN\">CNodeJS用户组：nodejs中文用户组</a></h3>\r\n<h3>订阅 cnodejs</h3>\r\n<form action=\"http://groups.google.com/group/cnodejs/boxsubscribe\">电子邮件：\r\n<input type=\"text\" name=\"email\" /> <input type=\"submit\" name=\"sub\" value=\"订阅\" /></form><a href=\"http://groups.google.com/group/cnodejs?hl=zh-CN\">访问此论坛</a>\r\n\r\n \r\n<h3>官方技术交流QQ群：<span style=\"color: #ff0000;\">53090214(已满)</span> <span style=\"color: #008000;\"> 40746652(开放)</span></h3>\r\n社区视频介绍：\r\n<object width=\"480\" height=\"400\" classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\"><param name=\"src\" value=\"http://www.tudou.com/v/QHWzAvGPifM/&rpid=9383267/v.swf\" /><param name=\"allowscriptaccess\" value=\"always\" /><param name=\"allowfullscreen\" value=\"true\" /><param name=\"wmode\" value=\"opaque\" /><embed width=\"480\" height=\"400\" type=\"application/x-shockwave-flash\" src=\"http://www.tudou.com/v/QHWzAvGPifM/&rpid=9383267/v.swf\" allowscriptaccess=\"always\" allowfullscreen=\"true\" wmode=\"opaque\" /></object>\r\n\r\n<h3>关于node.js</h3>\r\nnode.js开源项目致力于提供一套编写高性能并发Web应用的JavaScript框架，完全事件驱动IO，基于V8引擎，很适合中间件和WEB项目开发。\r\n\r\n特点：\r\n\r\n* 单线程事件模型，简单高效\r\n* 基于活跃的高性能V8引擎\r\n* 社区活跃，组件丰富","title":"关于CNode社区","last_reply_at":"2013-07-01T16:11:00.572Z","good":false,"top":false,"reply_count":7,"visit_count":4235,"create_at":"2012-01-19T05:45:12.985Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4f152db38b3242105b00405d","author_id":"4efc278525fa69ac6900000f","content":"<p>我想按行分析文件数据。目前还没有发现有什么好的模块能实现按行读取文件。</p>\n\n<p>各位有经验分享一下吗？</p>","title":"nodejs中如何按行读取文件？","last_reply_at":"2016-05-19T06:09:32.624Z","good":false,"top":false,"reply_count":13,"visit_count":25825,"create_at":"2012-01-17T08:13:39.285Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4f0fc6049bd0101e37002b1b","author_id":"4efc278525fa69ac6900000f","content":"![enter image description here][1] ![](http://nodejs.org/logos/nodejs.png)\r\n\r\nSites:\r\n\r\n* [Travis CI](http://travis-ci.org/) (需要翻墙): Travis CI is a continuous integration system. Long story short: continuous integrations systems run your tests\r\n\r\nBlogs:\r\n\r\n* [nodejitsu blog](http://blog.nodejitsu.com)\r\n* [Issac Z. Schlueter](http://blog.izs.me/)\r\n* [TJ Holowaychuk](http://tjholowaychuk.com)\r\n\r\nGithub:\r\n\r\n* [Ryan Dahl](https://github.com/ry)\r\n* [TJ Holowaychuk](https://github.com/visionmedia)\r\n* [LearnBoost](https://github.com/LearnBoost)\r\n\r\n大家有什么好的推荐？\r\n\r\n\r\n  [1]: http://nodejs.org/logos/nodejs-green.png","title":"Nodejs相关网站和博客","last_reply_at":"2012-02-22T06:15:14.598Z","good":false,"top":false,"reply_count":7,"visit_count":3738,"create_at":"2012-01-13T05:49:56.599Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4f0fc4649bd0101e37001e22","author_id":"4efc278525fa69ac6900000f","content":"<p>CNode邮件组的[@SeanLv](/user/SeanLv) 同学发了一篇推荐文章</p>\n\n<blockquote>\n  <p>就像best editor一样，programming style也是程序员一直争论的话题。\n  这里我不想引发争论，只是在网上看到的好文转发过来。\n  <a href=\"Programming Styles in the Node Community\">http://dailyjs.com/2012/01/12/style/</a>\n  主要是希望给一直纠结于style这个问题的朋友一点参考。</p>\n</blockquote>\n\n<p>大家有什么想法呢？一起讨论一下吧。</p>","title":"Programming Styles in the Node Community","last_reply_at":"2012-01-13T05:43:43.572Z","good":false,"top":false,"reply_count":2,"visit_count":2332,"create_at":"2012-01-13T05:43:00.604Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4efd16cdcc797d800d001b11","author_id":"4efc278525fa69ac69000003","content":"请畅所欲言，有任何不爽的地方、期待增加的功能都请提出来\r\n\r\n    console.log(\"hello, NodeClub guys\");","title":"用Node开发的NodeClub，专为Noder设计","last_reply_at":"2012-02-02T02:45:53.834Z","good":false,"top":false,"reply_count":14,"visit_count":3828,"create_at":"2011-12-30T01:41:33.540Z","author":{"loginname":"kongwu","avatar_url":"//gravatar.com/avatar/1bfc8def4d9f790b4157a17aeba5f55e?s=48"}},{"id":"4f0674e3da2949c52f001caf","author_id":"4efc278525fa69ac6900000f","content":"<p>大家都做好防御了吗？</p>","title":"Hash冲突DDos","last_reply_at":"2012-01-13T05:34:41.476Z","good":false,"top":false,"reply_count":2,"visit_count":2627,"create_at":"2012-01-06T04:13:23.218Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4efc39546d88ae8a6f000160","author_id":"4efc278525fa69ac6900000f","content":"<h3>一些概念</h3>\n\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Test-driven_development\">TDD</a>: Test-driven development </li>\n<li><a href=\"http://en.wikipedia.org/wiki/Behavior_Driven_Development\">BDD</a>: Behavior Driven Development </li>\n</ul>\n\n<h3>一些相关模块</h3>\n\n<ul>\n<li><a href=\"http://visionmedia.github.com/mocha/\">mocha</a></li>\n<li><a href=\"https://github.com/visionmedia/should.js\">should.js</a></li>\n<li><a href=\"http://visionmedia.github.com/expresso/\">expresso</a></li>\n<li><a href=\"https://github.com/caolan/nodeunit\">nodeunit</a></li>\n<li><a href=\"https://github.com/cloudhead/vows\">Vows</a></li>\n</ul>","title":"大家会写单元测试吗？","last_reply_at":"2012-05-29T06:18:03.108Z","good":false,"top":false,"reply_count":3,"visit_count":2785,"create_at":"2011-12-29T09:56:36.477Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4efc3a756d88ae8a6f0002e6","author_id":"4efc278525fa69ac6900000f","content":"<h3>我知道的</h3>\n\n<ul>\n<li><a href=\"https://trello.com\">Trello</a></li>\n<li><a href=\"https://www.learnboost.com/\">LearnBoost</a></li>\n<li><a href=\"http://shu.taobao.com/\">淘宝指数</a></li>\n</ul>","title":"目前有哪些应用是使用Nodejs的？","last_reply_at":"2012-05-31T03:32:44.361Z","good":false,"top":false,"reply_count":3,"visit_count":2776,"create_at":"2011-12-29T10:01:25.453Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4efc3b9c6d88ae8a6f00045c","author_id":"4efc278525fa69ac6900000f","content":"<p><a href=\"http://nodebeginner.org/index-zh-cn.html\">《Node 入门》</a></p>","title":"Nodejs新手入门，有哪些教材，文章和资源推荐？","last_reply_at":"2012-09-26T03:17:46.896Z","good":false,"top":false,"reply_count":10,"visit_count":5363,"create_at":"2011-12-29T10:06:20.478Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}},{"id":"4efc372a6d88ae8a6f000019","author_id":"4efc278525fa69ac6900000f","content":"<p>支持 Markdown 语法高亮喔！</p>\r\n\r\n<pre><code>http.createServer(function(req, res) {\r\n  res.end('Hello World!');\r\n});\r\n</code></pre>\r\n\r\n<p>没有分页的时候，分页buttons是否可以隐藏掉？</p>\r\n\r\n<p><img src=\"http://ww3.sinaimg.cn/large/6cfc7910jw1dojlz8ey4pj.jpg\" alt=\"enter image description here\" title=\"\" /></p>","title":"Node Club 测试开始，大家有什么要吐槽的？","last_reply_at":"2012-08-08T07:09:09.956Z","good":false,"top":false,"reply_count":64,"visit_count":5142,"create_at":"2011-12-29T09:47:22.559Z","author":{"loginname":"fengmk2","avatar_url":"https://avatars3.githubusercontent.com/u/156269?v=3&s=120"}}]}